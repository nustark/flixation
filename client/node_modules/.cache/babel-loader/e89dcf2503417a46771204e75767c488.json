{"ast":null,"code":"import _classCallCheck from \"/Users/thurman/CS/React/streams/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _possibleConstructorReturn from \"/Users/thurman/CS/React/streams/client/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/thurman/CS/React/streams/client/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"/Users/thurman/CS/React/streams/client/node_modules/@babel/runtime/helpers/esm/get\";\nimport _createClass from \"/Users/thurman/CS/React/streams/client/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/thurman/CS/React/streams/client/node_modules/@babel/runtime/helpers/esm/inherits\";\n\n/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport Log from '../utils/logger.js';\nimport { BaseLoader, LoaderStatus, LoaderErrors } from './loader.js';\nimport { RuntimeException } from '../utils/exception.js'; // For FLV over WebSocket live stream\n\nvar WebSocketLoader =\n/*#__PURE__*/\nfunction (_BaseLoader) {\n  _inherits(WebSocketLoader, _BaseLoader);\n\n  _createClass(WebSocketLoader, null, [{\n    key: \"isSupported\",\n    value: function isSupported() {\n      try {\n        return typeof self.WebSocket !== 'undefined';\n      } catch (e) {\n        return false;\n      }\n    }\n  }]);\n\n  function WebSocketLoader() {\n    var _this;\n\n    _classCallCheck(this, WebSocketLoader);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(WebSocketLoader).call(this, 'websocket-loader'));\n    _this.TAG = 'WebSocketLoader';\n    _this._needStash = true;\n    _this._ws = null;\n    _this._requestAbort = false;\n    _this._receivedLength = 0;\n    return _this;\n  }\n\n  _createClass(WebSocketLoader, [{\n    key: \"destroy\",\n    value: function destroy() {\n      if (this._ws) {\n        this.abort();\n      }\n\n      _get(_getPrototypeOf(WebSocketLoader.prototype), \"destroy\", this).call(this);\n    }\n  }, {\n    key: \"open\",\n    value: function open(dataSource) {\n      try {\n        var ws = this._ws = new self.WebSocket(dataSource.url);\n        ws.binaryType = 'arraybuffer';\n        ws.onopen = this._onWebSocketOpen.bind(this);\n        ws.onclose = this._onWebSocketClose.bind(this);\n        ws.onmessage = this._onWebSocketMessage.bind(this);\n        ws.onerror = this._onWebSocketError.bind(this);\n        this._status = LoaderStatus.kConnecting;\n      } catch (e) {\n        this._status = LoaderStatus.kError;\n        var info = {\n          code: e.code,\n          msg: e.message\n        };\n\n        if (this._onError) {\n          this._onError(LoaderErrors.EXCEPTION, info);\n        } else {\n          throw new RuntimeException(info.msg);\n        }\n      }\n    }\n  }, {\n    key: \"abort\",\n    value: function abort() {\n      var ws = this._ws;\n\n      if (ws && (ws.readyState === 0 || ws.readyState === 1)) {\n        // CONNECTING || OPEN\n        this._requestAbort = true;\n        ws.close();\n      }\n\n      this._ws = null;\n      this._status = LoaderStatus.kComplete;\n    }\n  }, {\n    key: \"_onWebSocketOpen\",\n    value: function _onWebSocketOpen(e) {\n      this._status = LoaderStatus.kBuffering;\n    }\n  }, {\n    key: \"_onWebSocketClose\",\n    value: function _onWebSocketClose(e) {\n      if (this._requestAbort === true) {\n        this._requestAbort = false;\n        return;\n      }\n\n      this._status = LoaderStatus.kComplete;\n\n      if (this._onComplete) {\n        this._onComplete(0, this._receivedLength - 1);\n      }\n    }\n  }, {\n    key: \"_onWebSocketMessage\",\n    value: function _onWebSocketMessage(e) {\n      var _this2 = this;\n\n      if (e.data instanceof ArrayBuffer) {\n        this._dispatchArrayBuffer(e.data);\n      } else if (e.data instanceof Blob) {\n        var reader = new FileReader();\n\n        reader.onload = function () {\n          _this2._dispatchArrayBuffer(reader.result);\n        };\n\n        reader.readAsArrayBuffer(e.data);\n      } else {\n        this._status = LoaderStatus.kError;\n        var info = {\n          code: -1,\n          msg: 'Unsupported WebSocket message type: ' + e.data.constructor.name\n        };\n\n        if (this._onError) {\n          this._onError(LoaderErrors.EXCEPTION, info);\n        } else {\n          throw new RuntimeException(info.msg);\n        }\n      }\n    }\n  }, {\n    key: \"_dispatchArrayBuffer\",\n    value: function _dispatchArrayBuffer(arraybuffer) {\n      var chunk = arraybuffer;\n      var byteStart = this._receivedLength;\n      this._receivedLength += chunk.byteLength;\n\n      if (this._onDataArrival) {\n        this._onDataArrival(chunk, byteStart, this._receivedLength);\n      }\n    }\n  }, {\n    key: \"_onWebSocketError\",\n    value: function _onWebSocketError(e) {\n      this._status = LoaderStatus.kError;\n      var info = {\n        code: e.code,\n        msg: e.message\n      };\n\n      if (this._onError) {\n        this._onError(LoaderErrors.EXCEPTION, info);\n      } else {\n        throw new RuntimeException(info.msg);\n      }\n    }\n  }]);\n\n  return WebSocketLoader;\n}(BaseLoader);\n\nexport default WebSocketLoader;","map":null,"metadata":{},"sourceType":"module"}