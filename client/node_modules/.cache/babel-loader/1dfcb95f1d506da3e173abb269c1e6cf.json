{"ast":null,"code":"import _classCallCheck from \"/Users/thurman/CS/React/streams/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/thurman/CS/React/streams/client/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport Log from '../utils/logger.js';\nimport SpeedSampler from './speed-sampler.js';\nimport { LoaderStatus, LoaderErrors } from './loader.js';\nimport FetchStreamLoader from './fetch-stream-loader.js';\nimport MozChunkedLoader from './xhr-moz-chunked-loader.js';\nimport MSStreamLoader from './xhr-msstream-loader.js';\nimport RangeLoader from './xhr-range-loader.js';\nimport WebSocketLoader from './websocket-loader.js';\nimport RangeSeekHandler from './range-seek-handler.js';\nimport ParamSeekHandler from './param-seek-handler.js';\nimport { RuntimeException, IllegalStateException, InvalidArgumentException } from '../utils/exception.js';\n/**\n * DataSource: {\n *     url: string,\n *     filesize: number,\n *     cors: boolean,\n *     withCredentials: boolean\n * }\n * \n */\n// Manage IO Loaders\n\nvar IOController =\n/*#__PURE__*/\nfunction () {\n  function IOController(dataSource, config, extraData) {\n    _classCallCheck(this, IOController);\n\n    this.TAG = 'IOController';\n    this._config = config;\n    this._extraData = extraData;\n    this._stashInitialSize = 1024 * 384; // default initial size: 384KB\n\n    if (config.stashInitialSize != undefined && config.stashInitialSize > 0) {\n      // apply from config\n      this._stashInitialSize = config.stashInitialSize;\n    }\n\n    this._stashUsed = 0;\n    this._stashSize = this._stashInitialSize;\n    this._bufferSize = 1024 * 1024 * 3; // initial size: 3MB\n\n    this._stashBuffer = new ArrayBuffer(this._bufferSize);\n    this._stashByteStart = 0;\n    this._enableStash = true;\n\n    if (config.enableStashBuffer === false) {\n      this._enableStash = false;\n    }\n\n    this._loader = null;\n    this._loaderClass = null;\n    this._seekHandler = null;\n    this._dataSource = dataSource;\n    this._isWebSocketURL = /wss?:\\/\\/(.+?)/.test(dataSource.url);\n    this._refTotalLength = dataSource.filesize ? dataSource.filesize : null;\n    this._totalLength = this._refTotalLength;\n    this._fullRequestFlag = false;\n    this._currentRange = null;\n    this._redirectedURL = null;\n    this._speedNormalized = 0;\n    this._speedSampler = new SpeedSampler();\n    this._speedNormalizeList = [64, 128, 256, 384, 512, 768, 1024, 1536, 2048, 3072, 4096];\n    this._isEarlyEofReconnecting = false;\n    this._paused = false;\n    this._resumeFrom = 0;\n    this._onDataArrival = null;\n    this._onSeeked = null;\n    this._onError = null;\n    this._onComplete = null;\n    this._onRedirect = null;\n    this._onRecoveredEarlyEof = null;\n\n    this._selectSeekHandler();\n\n    this._selectLoader();\n\n    this._createLoader();\n  }\n\n  _createClass(IOController, [{\n    key: \"destroy\",\n    value: function destroy() {\n      if (this._loader.isWorking()) {\n        this._loader.abort();\n      }\n\n      this._loader.destroy();\n\n      this._loader = null;\n      this._loaderClass = null;\n      this._dataSource = null;\n      this._stashBuffer = null;\n      this._stashUsed = this._stashSize = this._bufferSize = this._stashByteStart = 0;\n      this._currentRange = null;\n      this._speedSampler = null;\n      this._isEarlyEofReconnecting = false;\n      this._onDataArrival = null;\n      this._onSeeked = null;\n      this._onError = null;\n      this._onComplete = null;\n      this._onRedirect = null;\n      this._onRecoveredEarlyEof = null;\n      this._extraData = null;\n    }\n  }, {\n    key: \"isWorking\",\n    value: function isWorking() {\n      return this._loader && this._loader.isWorking() && !this._paused;\n    }\n  }, {\n    key: \"isPaused\",\n    value: function isPaused() {\n      return this._paused;\n    }\n  }, {\n    key: \"_selectSeekHandler\",\n    value: function _selectSeekHandler() {\n      var config = this._config;\n\n      if (config.seekType === 'range') {\n        this._seekHandler = new RangeSeekHandler(this._config.rangeLoadZeroStart);\n      } else if (config.seekType === 'param') {\n        var paramStart = config.seekParamStart || 'bstart';\n        var paramEnd = config.seekParamEnd || 'bend';\n        this._seekHandler = new ParamSeekHandler(paramStart, paramEnd);\n      } else if (config.seekType === 'custom') {\n        if (typeof config.customSeekHandler !== 'function') {\n          throw new InvalidArgumentException('Custom seekType specified in config but invalid customSeekHandler!');\n        }\n\n        this._seekHandler = new config.customSeekHandler();\n      } else {\n        throw new InvalidArgumentException(\"Invalid seekType in config: \".concat(config.seekType));\n      }\n    }\n  }, {\n    key: \"_selectLoader\",\n    value: function _selectLoader() {\n      if (this._config.customLoader != null) {\n        this._loaderClass = this._config.customLoader;\n      } else if (this._isWebSocketURL) {\n        this._loaderClass = WebSocketLoader;\n      } else if (FetchStreamLoader.isSupported()) {\n        this._loaderClass = FetchStreamLoader;\n      } else if (MozChunkedLoader.isSupported()) {\n        this._loaderClass = MozChunkedLoader;\n      } else if (RangeLoader.isSupported()) {\n        this._loaderClass = RangeLoader;\n      } else {\n        throw new RuntimeException('Your browser doesn\\'t support xhr with arraybuffer responseType!');\n      }\n    }\n  }, {\n    key: \"_createLoader\",\n    value: function _createLoader() {\n      this._loader = new this._loaderClass(this._seekHandler, this._config);\n\n      if (this._loader.needStashBuffer === false) {\n        this._enableStash = false;\n      }\n\n      this._loader.onContentLengthKnown = this._onContentLengthKnown.bind(this);\n      this._loader.onURLRedirect = this._onURLRedirect.bind(this);\n      this._loader.onDataArrival = this._onLoaderChunkArrival.bind(this);\n      this._loader.onComplete = this._onLoaderComplete.bind(this);\n      this._loader.onError = this._onLoaderError.bind(this);\n    }\n  }, {\n    key: \"open\",\n    value: function open(optionalFrom) {\n      this._currentRange = {\n        from: 0,\n        to: -1\n      };\n\n      if (optionalFrom) {\n        this._currentRange.from = optionalFrom;\n      }\n\n      this._speedSampler.reset();\n\n      if (!optionalFrom) {\n        this._fullRequestFlag = true;\n      }\n\n      this._loader.open(this._dataSource, Object.assign({}, this._currentRange));\n    }\n  }, {\n    key: \"abort\",\n    value: function abort() {\n      this._loader.abort();\n\n      if (this._paused) {\n        this._paused = false;\n        this._resumeFrom = 0;\n      }\n    }\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      if (this.isWorking()) {\n        this._loader.abort();\n\n        if (this._stashUsed !== 0) {\n          this._resumeFrom = this._stashByteStart;\n          this._currentRange.to = this._stashByteStart - 1;\n        } else {\n          this._resumeFrom = this._currentRange.to + 1;\n        }\n\n        this._stashUsed = 0;\n        this._stashByteStart = 0;\n        this._paused = true;\n      }\n    }\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      if (this._paused) {\n        this._paused = false;\n        var bytes = this._resumeFrom;\n        this._resumeFrom = 0;\n\n        this._internalSeek(bytes, true);\n      }\n    }\n  }, {\n    key: \"seek\",\n    value: function seek(bytes) {\n      this._paused = false;\n      this._stashUsed = 0;\n      this._stashByteStart = 0;\n\n      this._internalSeek(bytes, true);\n    }\n    /**\n     * When seeking request is from media seeking, unconsumed stash data should be dropped\n     * However, stash data shouldn't be dropped if seeking requested from http reconnection\n     *\n     * @dropUnconsumed: Ignore and discard all unconsumed data in stash buffer\n     */\n\n  }, {\n    key: \"_internalSeek\",\n    value: function _internalSeek(bytes, dropUnconsumed) {\n      if (this._loader.isWorking()) {\n        this._loader.abort();\n      } // dispatch & flush stash buffer before seek\n\n\n      this._flushStashBuffer(dropUnconsumed);\n\n      this._loader.destroy();\n\n      this._loader = null;\n      var requestRange = {\n        from: bytes,\n        to: -1\n      };\n      this._currentRange = {\n        from: requestRange.from,\n        to: -1\n      };\n\n      this._speedSampler.reset();\n\n      this._stashSize = this._stashInitialSize;\n\n      this._createLoader();\n\n      this._loader.open(this._dataSource, requestRange);\n\n      if (this._onSeeked) {\n        this._onSeeked();\n      }\n    }\n  }, {\n    key: \"updateUrl\",\n    value: function updateUrl(url) {\n      if (!url || typeof url !== 'string' || url.length === 0) {\n        throw new InvalidArgumentException('Url must be a non-empty string!');\n      }\n\n      this._dataSource.url = url; // TODO: replace with new url\n    }\n  }, {\n    key: \"_expandBuffer\",\n    value: function _expandBuffer(expectedBytes) {\n      var bufferNewSize = this._stashSize;\n\n      while (bufferNewSize + 1024 * 1024 * 1 < expectedBytes) {\n        bufferNewSize *= 2;\n      }\n\n      bufferNewSize += 1024 * 1024 * 1; // bufferSize = stashSize + 1MB\n\n      if (bufferNewSize === this._bufferSize) {\n        return;\n      }\n\n      var newBuffer = new ArrayBuffer(bufferNewSize);\n\n      if (this._stashUsed > 0) {\n        // copy existing data into new buffer\n        var stashOldArray = new Uint8Array(this._stashBuffer, 0, this._stashUsed);\n        var stashNewArray = new Uint8Array(newBuffer, 0, bufferNewSize);\n        stashNewArray.set(stashOldArray, 0);\n      }\n\n      this._stashBuffer = newBuffer;\n      this._bufferSize = bufferNewSize;\n    }\n  }, {\n    key: \"_normalizeSpeed\",\n    value: function _normalizeSpeed(input) {\n      var list = this._speedNormalizeList;\n      var last = list.length - 1;\n      var mid = 0;\n      var lbound = 0;\n      var ubound = last;\n\n      if (input < list[0]) {\n        return list[0];\n      } // binary search\n\n\n      while (lbound <= ubound) {\n        mid = lbound + Math.floor((ubound - lbound) / 2);\n\n        if (mid === last || input >= list[mid] && input < list[mid + 1]) {\n          return list[mid];\n        } else if (list[mid] < input) {\n          lbound = mid + 1;\n        } else {\n          ubound = mid - 1;\n        }\n      }\n    }\n  }, {\n    key: \"_adjustStashSize\",\n    value: function _adjustStashSize(normalized) {\n      var stashSizeKB = 0;\n\n      if (this._config.isLive) {\n        // live stream: always use single normalized speed for size of stashSizeKB\n        stashSizeKB = normalized;\n      } else {\n        if (normalized < 512) {\n          stashSizeKB = normalized;\n        } else if (normalized >= 512 && normalized <= 1024) {\n          stashSizeKB = Math.floor(normalized * 1.5);\n        } else {\n          stashSizeKB = normalized * 2;\n        }\n      }\n\n      if (stashSizeKB > 8192) {\n        stashSizeKB = 8192;\n      }\n\n      var bufferSize = stashSizeKB * 1024 + 1024 * 1024 * 1; // stashSize + 1MB\n\n      if (this._bufferSize < bufferSize) {\n        this._expandBuffer(bufferSize);\n      }\n\n      this._stashSize = stashSizeKB * 1024;\n    }\n  }, {\n    key: \"_dispatchChunks\",\n    value: function _dispatchChunks(chunks, byteStart) {\n      this._currentRange.to = byteStart + chunks.byteLength - 1;\n      return this._onDataArrival(chunks, byteStart);\n    }\n  }, {\n    key: \"_onURLRedirect\",\n    value: function _onURLRedirect(redirectedURL) {\n      this._redirectedURL = redirectedURL;\n\n      if (this._onRedirect) {\n        this._onRedirect(redirectedURL);\n      }\n    }\n  }, {\n    key: \"_onContentLengthKnown\",\n    value: function _onContentLengthKnown(contentLength) {\n      if (contentLength && this._fullRequestFlag) {\n        this._totalLength = contentLength;\n        this._fullRequestFlag = false;\n      }\n    }\n  }, {\n    key: \"_onLoaderChunkArrival\",\n    value: function _onLoaderChunkArrival(chunk, byteStart, receivedLength) {\n      if (!this._onDataArrival) {\n        throw new IllegalStateException('IOController: No existing consumer (onDataArrival) callback!');\n      }\n\n      if (this._paused) {\n        return;\n      }\n\n      if (this._isEarlyEofReconnecting) {\n        // Auto-reconnect for EarlyEof succeed, notify to upper-layer by callback\n        this._isEarlyEofReconnecting = false;\n\n        if (this._onRecoveredEarlyEof) {\n          this._onRecoveredEarlyEof();\n        }\n      }\n\n      this._speedSampler.addBytes(chunk.byteLength); // adjust stash buffer size according to network speed dynamically\n\n\n      var KBps = this._speedSampler.lastSecondKBps;\n\n      if (KBps !== 0) {\n        var normalized = this._normalizeSpeed(KBps);\n\n        if (this._speedNormalized !== normalized) {\n          this._speedNormalized = normalized;\n\n          this._adjustStashSize(normalized);\n        }\n      }\n\n      if (!this._enableStash) {\n        // disable stash\n        if (this._stashUsed === 0) {\n          // dispatch chunk directly to consumer;\n          // check ret value (consumed bytes) and stash unconsumed to stashBuffer\n          var consumed = this._dispatchChunks(chunk, byteStart);\n\n          if (consumed < chunk.byteLength) {\n            // unconsumed data remain.\n            var remain = chunk.byteLength - consumed;\n\n            if (remain > this._bufferSize) {\n              this._expandBuffer(remain);\n            }\n\n            var stashArray = new Uint8Array(this._stashBuffer, 0, this._bufferSize);\n            stashArray.set(new Uint8Array(chunk, consumed), 0);\n            this._stashUsed += remain;\n            this._stashByteStart = byteStart + consumed;\n          }\n        } else {\n          // else: Merge chunk into stashBuffer, and dispatch stashBuffer to consumer.\n          if (this._stashUsed + chunk.byteLength > this._bufferSize) {\n            this._expandBuffer(this._stashUsed + chunk.byteLength);\n          }\n\n          var _stashArray = new Uint8Array(this._stashBuffer, 0, this._bufferSize);\n\n          _stashArray.set(new Uint8Array(chunk), this._stashUsed);\n\n          this._stashUsed += chunk.byteLength;\n\n          var _consumed = this._dispatchChunks(this._stashBuffer.slice(0, this._stashUsed), this._stashByteStart);\n\n          if (_consumed < this._stashUsed && _consumed > 0) {\n            // unconsumed data remain\n            var remainArray = new Uint8Array(this._stashBuffer, _consumed);\n\n            _stashArray.set(remainArray, 0);\n          }\n\n          this._stashUsed -= _consumed;\n          this._stashByteStart += _consumed;\n        }\n      } else {\n        // enable stash\n        if (this._stashUsed === 0 && this._stashByteStart === 0) {\n          // seeked? or init chunk?\n          // This is the first chunk after seek action\n          this._stashByteStart = byteStart;\n        }\n\n        if (this._stashUsed + chunk.byteLength <= this._stashSize) {\n          // just stash\n          var _stashArray2 = new Uint8Array(this._stashBuffer, 0, this._stashSize);\n\n          _stashArray2.set(new Uint8Array(chunk), this._stashUsed);\n\n          this._stashUsed += chunk.byteLength;\n        } else {\n          // stashUsed + chunkSize > stashSize, size limit exceeded\n          var _stashArray3 = new Uint8Array(this._stashBuffer, 0, this._bufferSize);\n\n          if (this._stashUsed > 0) {\n            // There're stash datas in buffer\n            // dispatch the whole stashBuffer, and stash remain data\n            // then append chunk to stashBuffer (stash)\n            var buffer = this._stashBuffer.slice(0, this._stashUsed);\n\n            var _consumed2 = this._dispatchChunks(buffer, this._stashByteStart);\n\n            if (_consumed2 < buffer.byteLength) {\n              if (_consumed2 > 0) {\n                var _remainArray = new Uint8Array(buffer, _consumed2);\n\n                _stashArray3.set(_remainArray, 0);\n\n                this._stashUsed = _remainArray.byteLength;\n                this._stashByteStart += _consumed2;\n              }\n            } else {\n              this._stashUsed = 0;\n              this._stashByteStart += _consumed2;\n            }\n\n            if (this._stashUsed + chunk.byteLength > this._bufferSize) {\n              this._expandBuffer(this._stashUsed + chunk.byteLength);\n\n              _stashArray3 = new Uint8Array(this._stashBuffer, 0, this._bufferSize);\n            }\n\n            _stashArray3.set(new Uint8Array(chunk), this._stashUsed);\n\n            this._stashUsed += chunk.byteLength;\n          } else {\n            // stash buffer empty, but chunkSize > stashSize (oh, holy shit)\n            // dispatch chunk directly and stash remain data\n            var _consumed3 = this._dispatchChunks(chunk, byteStart);\n\n            if (_consumed3 < chunk.byteLength) {\n              var _remain = chunk.byteLength - _consumed3;\n\n              if (_remain > this._bufferSize) {\n                this._expandBuffer(_remain);\n\n                _stashArray3 = new Uint8Array(this._stashBuffer, 0, this._bufferSize);\n              }\n\n              _stashArray3.set(new Uint8Array(chunk, _consumed3), 0);\n\n              this._stashUsed += _remain;\n              this._stashByteStart = byteStart + _consumed3;\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_flushStashBuffer\",\n    value: function _flushStashBuffer(dropUnconsumed) {\n      if (this._stashUsed > 0) {\n        var buffer = this._stashBuffer.slice(0, this._stashUsed);\n\n        var consumed = this._dispatchChunks(buffer, this._stashByteStart);\n\n        var remain = buffer.byteLength - consumed;\n\n        if (consumed < buffer.byteLength) {\n          if (dropUnconsumed) {\n            Log.w(this.TAG, \"\".concat(remain, \" bytes unconsumed data remain when flush buffer, dropped\"));\n          } else {\n            if (consumed > 0) {\n              var stashArray = new Uint8Array(this._stashBuffer, 0, this._bufferSize);\n              var remainArray = new Uint8Array(buffer, consumed);\n              stashArray.set(remainArray, 0);\n              this._stashUsed = remainArray.byteLength;\n              this._stashByteStart += consumed;\n            }\n\n            return 0;\n          }\n        }\n\n        this._stashUsed = 0;\n        this._stashByteStart = 0;\n        return remain;\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"_onLoaderComplete\",\n    value: function _onLoaderComplete(from, to) {\n      // Force-flush stash buffer, and drop unconsumed data\n      this._flushStashBuffer(true);\n\n      if (this._onComplete) {\n        this._onComplete(this._extraData);\n      }\n    }\n  }, {\n    key: \"_onLoaderError\",\n    value: function _onLoaderError(type, data) {\n      Log.e(this.TAG, \"Loader error, code = \".concat(data.code, \", msg = \").concat(data.msg));\n\n      this._flushStashBuffer(false);\n\n      if (this._isEarlyEofReconnecting) {\n        // Auto-reconnect for EarlyEof failed, throw UnrecoverableEarlyEof error to upper-layer\n        this._isEarlyEofReconnecting = false;\n        type = LoaderErrors.UNRECOVERABLE_EARLY_EOF;\n      }\n\n      switch (type) {\n        case LoaderErrors.EARLY_EOF:\n          {\n            if (!this._config.isLive) {\n              // Do internal http reconnect if not live stream\n              if (this._totalLength) {\n                var nextFrom = this._currentRange.to + 1;\n\n                if (nextFrom < this._totalLength) {\n                  Log.w(this.TAG, 'Connection lost, trying reconnect...');\n                  this._isEarlyEofReconnecting = true;\n\n                  this._internalSeek(nextFrom, false);\n                }\n\n                return;\n              } // else: We don't know totalLength, throw UnrecoverableEarlyEof\n\n            } // live stream: throw UnrecoverableEarlyEof error to upper-layer\n\n\n            type = LoaderErrors.UNRECOVERABLE_EARLY_EOF;\n            break;\n          }\n\n        case LoaderErrors.UNRECOVERABLE_EARLY_EOF:\n        case LoaderErrors.CONNECTING_TIMEOUT:\n        case LoaderErrors.HTTP_STATUS_CODE_INVALID:\n        case LoaderErrors.EXCEPTION:\n          break;\n      }\n\n      if (this._onError) {\n        this._onError(type, data);\n      } else {\n        throw new RuntimeException('IOException: ' + data.msg);\n      }\n    }\n  }, {\n    key: \"status\",\n    get: function get() {\n      return this._loader.status;\n    }\n  }, {\n    key: \"extraData\",\n    get: function get() {\n      return this._extraData;\n    },\n    set: function set(data) {\n      this._extraData = data;\n    } // prototype: function onDataArrival(chunks: ArrayBuffer, byteStart: number): number\n\n  }, {\n    key: \"onDataArrival\",\n    get: function get() {\n      return this._onDataArrival;\n    },\n    set: function set(callback) {\n      this._onDataArrival = callback;\n    }\n  }, {\n    key: \"onSeeked\",\n    get: function get() {\n      return this._onSeeked;\n    },\n    set: function set(callback) {\n      this._onSeeked = callback;\n    } // prototype: function onError(type: number, info: {code: number, msg: string}): void\n\n  }, {\n    key: \"onError\",\n    get: function get() {\n      return this._onError;\n    },\n    set: function set(callback) {\n      this._onError = callback;\n    }\n  }, {\n    key: \"onComplete\",\n    get: function get() {\n      return this._onComplete;\n    },\n    set: function set(callback) {\n      this._onComplete = callback;\n    }\n  }, {\n    key: \"onRedirect\",\n    get: function get() {\n      return this._onRedirect;\n    },\n    set: function set(callback) {\n      this._onRedirect = callback;\n    }\n  }, {\n    key: \"onRecoveredEarlyEof\",\n    get: function get() {\n      return this._onRecoveredEarlyEof;\n    },\n    set: function set(callback) {\n      this._onRecoveredEarlyEof = callback;\n    }\n  }, {\n    key: \"currentURL\",\n    get: function get() {\n      return this._dataSource.url;\n    }\n  }, {\n    key: \"hasRedirect\",\n    get: function get() {\n      return this._redirectedURL != null || this._dataSource.redirectedURL != undefined;\n    }\n  }, {\n    key: \"currentRedirectedURL\",\n    get: function get() {\n      return this._redirectedURL || this._dataSource.redirectedURL;\n    } // in KB/s\n\n  }, {\n    key: \"currentSpeed\",\n    get: function get() {\n      if (this._loaderClass === RangeLoader) {\n        // SpeedSampler is inaccuracy if loader is RangeLoader\n        return this._loader.currentSpeed;\n      }\n\n      return this._speedSampler.lastSecondKBps;\n    }\n  }, {\n    key: \"loaderType\",\n    get: function get() {\n      return this._loader.type;\n    }\n  }]);\n\n  return IOController;\n}();\n\nexport default IOController;","map":null,"metadata":{},"sourceType":"module"}