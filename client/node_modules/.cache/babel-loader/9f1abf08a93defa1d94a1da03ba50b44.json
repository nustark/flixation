{"ast":null,"code":"import _classCallCheck from \"/Users/thurman/CS/React/streams/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _possibleConstructorReturn from \"/Users/thurman/CS/React/streams/client/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/thurman/CS/React/streams/client/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"/Users/thurman/CS/React/streams/client/node_modules/@babel/runtime/helpers/esm/get\";\nimport _createClass from \"/Users/thurman/CS/React/streams/client/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/thurman/CS/React/streams/client/node_modules/@babel/runtime/helpers/esm/inherits\";\n\n/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport Log from '../utils/logger.js';\nimport SpeedSampler from './speed-sampler.js';\nimport { BaseLoader, LoaderStatus, LoaderErrors } from './loader.js';\nimport { RuntimeException } from '../utils/exception.js'; // Universal IO Loader, implemented by adding Range header in xhr's request header\n\nvar RangeLoader =\n/*#__PURE__*/\nfunction (_BaseLoader) {\n  _inherits(RangeLoader, _BaseLoader);\n\n  _createClass(RangeLoader, null, [{\n    key: \"isSupported\",\n    value: function isSupported() {\n      try {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', 'https://example.com', true);\n        xhr.responseType = 'arraybuffer';\n        return xhr.responseType === 'arraybuffer';\n      } catch (e) {\n        Log.w('RangeLoader', e.message);\n        return false;\n      }\n    }\n  }]);\n\n  function RangeLoader(seekHandler, config) {\n    var _this;\n\n    _classCallCheck(this, RangeLoader);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(RangeLoader).call(this, 'xhr-range-loader'));\n    _this.TAG = 'RangeLoader';\n    _this._seekHandler = seekHandler;\n    _this._config = config;\n    _this._needStash = false;\n    _this._chunkSizeKBList = [128, 256, 384, 512, 768, 1024, 1536, 2048, 3072, 4096, 5120, 6144, 7168, 8192];\n    _this._currentChunkSizeKB = 384;\n    _this._currentSpeedNormalized = 0;\n    _this._zeroSpeedChunkCount = 0;\n    _this._xhr = null;\n    _this._speedSampler = new SpeedSampler();\n    _this._requestAbort = false;\n    _this._waitForTotalLength = false;\n    _this._totalLengthReceived = false;\n    _this._currentRequestURL = null;\n    _this._currentRedirectedURL = null;\n    _this._currentRequestRange = null;\n    _this._totalLength = null; // size of the entire file\n\n    _this._contentLength = null; // Content-Length of entire request range\n\n    _this._receivedLength = 0; // total received bytes\n\n    _this._lastTimeLoaded = 0; // received bytes of current request sub-range\n\n    return _this;\n  }\n\n  _createClass(RangeLoader, [{\n    key: \"destroy\",\n    value: function destroy() {\n      if (this.isWorking()) {\n        this.abort();\n      }\n\n      if (this._xhr) {\n        this._xhr.onreadystatechange = null;\n        this._xhr.onprogress = null;\n        this._xhr.onload = null;\n        this._xhr.onerror = null;\n        this._xhr = null;\n      }\n\n      _get(_getPrototypeOf(RangeLoader.prototype), \"destroy\", this).call(this);\n    }\n  }, {\n    key: \"open\",\n    value: function open(dataSource, range) {\n      this._dataSource = dataSource;\n      this._range = range;\n      this._status = LoaderStatus.kConnecting;\n      var useRefTotalLength = false;\n\n      if (this._dataSource.filesize != undefined && this._dataSource.filesize !== 0) {\n        useRefTotalLength = true;\n        this._totalLength = this._dataSource.filesize;\n      }\n\n      if (!this._totalLengthReceived && !useRefTotalLength) {\n        // We need total filesize\n        this._waitForTotalLength = true;\n\n        this._internalOpen(this._dataSource, {\n          from: 0,\n          to: -1\n        });\n      } else {\n        // We have filesize, start loading\n        this._openSubRange();\n      }\n    }\n  }, {\n    key: \"_openSubRange\",\n    value: function _openSubRange() {\n      var chunkSize = this._currentChunkSizeKB * 1024;\n      var from = this._range.from + this._receivedLength;\n      var to = from + chunkSize;\n\n      if (this._contentLength != null) {\n        if (to - this._range.from >= this._contentLength) {\n          to = this._range.from + this._contentLength - 1;\n        }\n      }\n\n      this._currentRequestRange = {\n        from: from,\n        to: to\n      };\n\n      this._internalOpen(this._dataSource, this._currentRequestRange);\n    }\n  }, {\n    key: \"_internalOpen\",\n    value: function _internalOpen(dataSource, range) {\n      this._lastTimeLoaded = 0;\n      var sourceURL = dataSource.url;\n\n      if (this._config.reuseRedirectedURL) {\n        if (this._currentRedirectedURL != undefined) {\n          sourceURL = this._currentRedirectedURL;\n        } else if (dataSource.redirectedURL != undefined) {\n          sourceURL = dataSource.redirectedURL;\n        }\n      }\n\n      var seekConfig = this._seekHandler.getConfig(sourceURL, range);\n\n      this._currentRequestURL = seekConfig.url;\n      var xhr = this._xhr = new XMLHttpRequest();\n      xhr.open('GET', seekConfig.url, true);\n      xhr.responseType = 'arraybuffer';\n      xhr.onreadystatechange = this._onReadyStateChange.bind(this);\n      xhr.onprogress = this._onProgress.bind(this);\n      xhr.onload = this._onLoad.bind(this);\n      xhr.onerror = this._onXhrError.bind(this);\n\n      if (dataSource.withCredentials) {\n        xhr.withCredentials = true;\n      }\n\n      if (typeof seekConfig.headers === 'object') {\n        var headers = seekConfig.headers;\n\n        for (var key in headers) {\n          if (headers.hasOwnProperty(key)) {\n            xhr.setRequestHeader(key, headers[key]);\n          }\n        }\n      } // add additional headers\n\n\n      if (typeof this._config.headers === 'object') {\n        var _headers = this._config.headers;\n\n        for (var _key in _headers) {\n          if (_headers.hasOwnProperty(_key)) {\n            xhr.setRequestHeader(_key, _headers[_key]);\n          }\n        }\n      }\n\n      xhr.send();\n    }\n  }, {\n    key: \"abort\",\n    value: function abort() {\n      this._requestAbort = true;\n\n      this._internalAbort();\n\n      this._status = LoaderStatus.kComplete;\n    }\n  }, {\n    key: \"_internalAbort\",\n    value: function _internalAbort() {\n      if (this._xhr) {\n        this._xhr.onreadystatechange = null;\n        this._xhr.onprogress = null;\n        this._xhr.onload = null;\n        this._xhr.onerror = null;\n\n        this._xhr.abort();\n\n        this._xhr = null;\n      }\n    }\n  }, {\n    key: \"_onReadyStateChange\",\n    value: function _onReadyStateChange(e) {\n      var xhr = e.target;\n\n      if (xhr.readyState === 2) {\n        // HEADERS_RECEIVED\n        if (xhr.responseURL != undefined) {\n          // if the browser support this property\n          var redirectedURL = this._seekHandler.removeURLParameters(xhr.responseURL);\n\n          if (xhr.responseURL !== this._currentRequestURL && redirectedURL !== this._currentRedirectedURL) {\n            this._currentRedirectedURL = redirectedURL;\n\n            if (this._onURLRedirect) {\n              this._onURLRedirect(redirectedURL);\n            }\n          }\n        }\n\n        if (xhr.status >= 200 && xhr.status <= 299) {\n          if (this._waitForTotalLength) {\n            return;\n          }\n\n          this._status = LoaderStatus.kBuffering;\n        } else {\n          this._status = LoaderStatus.kError;\n\n          if (this._onError) {\n            this._onError(LoaderErrors.HTTP_STATUS_CODE_INVALID, {\n              code: xhr.status,\n              msg: xhr.statusText\n            });\n          } else {\n            throw new RuntimeException('RangeLoader: Http code invalid, ' + xhr.status + ' ' + xhr.statusText);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_onProgress\",\n    value: function _onProgress(e) {\n      if (this._status === LoaderStatus.kError) {\n        // Ignore error response\n        return;\n      }\n\n      if (this._contentLength === null) {\n        var openNextRange = false;\n\n        if (this._waitForTotalLength) {\n          this._waitForTotalLength = false;\n          this._totalLengthReceived = true;\n          openNextRange = true;\n          var total = e.total;\n\n          this._internalAbort();\n\n          if (total != null & total !== 0) {\n            this._totalLength = total;\n          }\n        } // calculate currrent request range's contentLength\n\n\n        if (this._range.to === -1) {\n          this._contentLength = this._totalLength - this._range.from;\n        } else {\n          // to !== -1\n          this._contentLength = this._range.to - this._range.from + 1;\n        }\n\n        if (openNextRange) {\n          this._openSubRange();\n\n          return;\n        }\n\n        if (this._onContentLengthKnown) {\n          this._onContentLengthKnown(this._contentLength);\n        }\n      }\n\n      var delta = e.loaded - this._lastTimeLoaded;\n      this._lastTimeLoaded = e.loaded;\n\n      this._speedSampler.addBytes(delta);\n    }\n  }, {\n    key: \"_normalizeSpeed\",\n    value: function _normalizeSpeed(input) {\n      var list = this._chunkSizeKBList;\n      var last = list.length - 1;\n      var mid = 0;\n      var lbound = 0;\n      var ubound = last;\n\n      if (input < list[0]) {\n        return list[0];\n      }\n\n      while (lbound <= ubound) {\n        mid = lbound + Math.floor((ubound - lbound) / 2);\n\n        if (mid === last || input >= list[mid] && input < list[mid + 1]) {\n          return list[mid];\n        } else if (list[mid] < input) {\n          lbound = mid + 1;\n        } else {\n          ubound = mid - 1;\n        }\n      }\n    }\n  }, {\n    key: \"_onLoad\",\n    value: function _onLoad(e) {\n      if (this._status === LoaderStatus.kError) {\n        // Ignore error response\n        return;\n      }\n\n      if (this._waitForTotalLength) {\n        this._waitForTotalLength = false;\n        return;\n      }\n\n      this._lastTimeLoaded = 0;\n      var KBps = this._speedSampler.lastSecondKBps;\n\n      if (KBps === 0) {\n        this._zeroSpeedChunkCount++;\n\n        if (this._zeroSpeedChunkCount >= 3) {\n          // Try get currentKBps after 3 chunks\n          KBps = this._speedSampler.currentKBps;\n        }\n      }\n\n      if (KBps !== 0) {\n        var normalized = this._normalizeSpeed(KBps);\n\n        if (this._currentSpeedNormalized !== normalized) {\n          this._currentSpeedNormalized = normalized;\n          this._currentChunkSizeKB = normalized;\n        }\n      }\n\n      var chunk = e.target.response;\n      var byteStart = this._range.from + this._receivedLength;\n      this._receivedLength += chunk.byteLength;\n      var reportComplete = false;\n\n      if (this._contentLength != null && this._receivedLength < this._contentLength) {\n        // continue load next chunk\n        this._openSubRange();\n      } else {\n        reportComplete = true;\n      } // dispatch received chunk\n\n\n      if (this._onDataArrival) {\n        this._onDataArrival(chunk, byteStart, this._receivedLength);\n      }\n\n      if (reportComplete) {\n        this._status = LoaderStatus.kComplete;\n\n        if (this._onComplete) {\n          this._onComplete(this._range.from, this._range.from + this._receivedLength - 1);\n        }\n      }\n    }\n  }, {\n    key: \"_onXhrError\",\n    value: function _onXhrError(e) {\n      this._status = LoaderStatus.kError;\n      var type = 0;\n      var info = null;\n\n      if (this._contentLength && this._receivedLength > 0 && this._receivedLength < this._contentLength) {\n        type = LoaderErrors.EARLY_EOF;\n        info = {\n          code: -1,\n          msg: 'RangeLoader meet Early-Eof'\n        };\n      } else {\n        type = LoaderErrors.EXCEPTION;\n        info = {\n          code: -1,\n          msg: e.constructor.name + ' ' + e.type\n        };\n      }\n\n      if (this._onError) {\n        this._onError(type, info);\n      } else {\n        throw new RuntimeException(info.msg);\n      }\n    }\n  }, {\n    key: \"currentSpeed\",\n    get: function get() {\n      return this._speedSampler.lastSecondKBps;\n    }\n  }]);\n\n  return RangeLoader;\n}(BaseLoader);\n\nexport default RangeLoader;","map":null,"metadata":{},"sourceType":"module"}