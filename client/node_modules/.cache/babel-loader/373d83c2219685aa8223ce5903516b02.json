{"ast":null,"code":"import _createClass from \"/Users/thurman/CS/React/streams/client/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _classCallCheck from \"/Users/thurman/CS/React/streams/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\n\n/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Represents an media sample (audio / video)\nexport var SampleInfo = function SampleInfo(dts, pts, duration, originalDts, isSync) {\n  _classCallCheck(this, SampleInfo);\n\n  this.dts = dts;\n  this.pts = pts;\n  this.duration = duration;\n  this.originalDts = originalDts;\n  this.isSyncPoint = isSync;\n  this.fileposition = null;\n}; // Media Segment concept is defined in Media Source Extensions spec.\n// Particularly in ISO BMFF format, an Media Segment contains a moof box followed by a mdat box.\n\nexport var MediaSegmentInfo =\n/*#__PURE__*/\nfunction () {\n  function MediaSegmentInfo() {\n    _classCallCheck(this, MediaSegmentInfo);\n\n    this.beginDts = 0;\n    this.endDts = 0;\n    this.beginPts = 0;\n    this.endPts = 0;\n    this.originalBeginDts = 0;\n    this.originalEndDts = 0;\n    this.syncPoints = []; // SampleInfo[n], for video IDR frames only\n\n    this.firstSample = null; // SampleInfo\n\n    this.lastSample = null; // SampleInfo\n  }\n\n  _createClass(MediaSegmentInfo, [{\n    key: \"appendSyncPoint\",\n    value: function appendSyncPoint(sampleInfo) {\n      // also called Random Access Point\n      sampleInfo.isSyncPoint = true;\n      this.syncPoints.push(sampleInfo);\n    }\n  }]);\n\n  return MediaSegmentInfo;\n}(); // Ordered list for recording video IDR frames, sorted by originalDts\n\nexport var IDRSampleList =\n/*#__PURE__*/\nfunction () {\n  function IDRSampleList() {\n    _classCallCheck(this, IDRSampleList);\n\n    this._list = [];\n  }\n\n  _createClass(IDRSampleList, [{\n    key: \"clear\",\n    value: function clear() {\n      this._list = [];\n    }\n  }, {\n    key: \"appendArray\",\n    value: function appendArray(syncPoints) {\n      var list = this._list;\n\n      if (syncPoints.length === 0) {\n        return;\n      }\n\n      if (list.length > 0 && syncPoints[0].originalDts < list[list.length - 1].originalDts) {\n        this.clear();\n      }\n\n      Array.prototype.push.apply(list, syncPoints);\n    }\n  }, {\n    key: \"getLastSyncPointBeforeDts\",\n    value: function getLastSyncPointBeforeDts(dts) {\n      if (this._list.length == 0) {\n        return null;\n      }\n\n      var list = this._list;\n      var idx = 0;\n      var last = list.length - 1;\n      var mid = 0;\n      var lbound = 0;\n      var ubound = last;\n\n      if (dts < list[0].dts) {\n        idx = 0;\n        lbound = ubound + 1;\n      }\n\n      while (lbound <= ubound) {\n        mid = lbound + Math.floor((ubound - lbound) / 2);\n\n        if (mid === last || dts >= list[mid].dts && dts < list[mid + 1].dts) {\n          idx = mid;\n          break;\n        } else if (list[mid].dts < dts) {\n          lbound = mid + 1;\n        } else {\n          ubound = mid - 1;\n        }\n      }\n\n      return this._list[idx];\n    }\n  }]);\n\n  return IDRSampleList;\n}(); // Data structure for recording information of media segments in single track.\n\nexport var MediaSegmentInfoList =\n/*#__PURE__*/\nfunction () {\n  function MediaSegmentInfoList(type) {\n    _classCallCheck(this, MediaSegmentInfoList);\n\n    this._type = type;\n    this._list = [];\n    this._lastAppendLocation = -1; // cached last insert location\n  }\n\n  _createClass(MediaSegmentInfoList, [{\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return this._list.length === 0;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this._list = [];\n      this._lastAppendLocation = -1;\n    }\n  }, {\n    key: \"_searchNearestSegmentBefore\",\n    value: function _searchNearestSegmentBefore(originalBeginDts) {\n      var list = this._list;\n\n      if (list.length === 0) {\n        return -2;\n      }\n\n      var last = list.length - 1;\n      var mid = 0;\n      var lbound = 0;\n      var ubound = last;\n      var idx = 0;\n\n      if (originalBeginDts < list[0].originalBeginDts) {\n        idx = -1;\n        return idx;\n      }\n\n      while (lbound <= ubound) {\n        mid = lbound + Math.floor((ubound - lbound) / 2);\n\n        if (mid === last || originalBeginDts > list[mid].lastSample.originalDts && originalBeginDts < list[mid + 1].originalBeginDts) {\n          idx = mid;\n          break;\n        } else if (list[mid].originalBeginDts < originalBeginDts) {\n          lbound = mid + 1;\n        } else {\n          ubound = mid - 1;\n        }\n      }\n\n      return idx;\n    }\n  }, {\n    key: \"_searchNearestSegmentAfter\",\n    value: function _searchNearestSegmentAfter(originalBeginDts) {\n      return this._searchNearestSegmentBefore(originalBeginDts) + 1;\n    }\n  }, {\n    key: \"append\",\n    value: function append(mediaSegmentInfo) {\n      var list = this._list;\n      var msi = mediaSegmentInfo;\n      var lastAppendIdx = this._lastAppendLocation;\n      var insertIdx = 0;\n\n      if (lastAppendIdx !== -1 && lastAppendIdx < list.length && msi.originalBeginDts >= list[lastAppendIdx].lastSample.originalDts && (lastAppendIdx === list.length - 1 || lastAppendIdx < list.length - 1 && msi.originalBeginDts < list[lastAppendIdx + 1].originalBeginDts)) {\n        insertIdx = lastAppendIdx + 1; // use cached location idx\n      } else {\n        if (list.length > 0) {\n          insertIdx = this._searchNearestSegmentBefore(msi.originalBeginDts) + 1;\n        }\n      }\n\n      this._lastAppendLocation = insertIdx;\n\n      this._list.splice(insertIdx, 0, msi);\n    }\n  }, {\n    key: \"getLastSegmentBefore\",\n    value: function getLastSegmentBefore(originalBeginDts) {\n      var idx = this._searchNearestSegmentBefore(originalBeginDts);\n\n      if (idx >= 0) {\n        return this._list[idx];\n      } else {\n        // -1\n        return null;\n      }\n    }\n  }, {\n    key: \"getLastSampleBefore\",\n    value: function getLastSampleBefore(originalBeginDts) {\n      var segment = this.getLastSegmentBefore(originalBeginDts);\n\n      if (segment != null) {\n        return segment.lastSample;\n      } else {\n        return null;\n      }\n    }\n  }, {\n    key: \"getLastSyncPointBefore\",\n    value: function getLastSyncPointBefore(originalBeginDts) {\n      var segmentIdx = this._searchNearestSegmentBefore(originalBeginDts);\n\n      var syncPoints = this._list[segmentIdx].syncPoints;\n\n      while (syncPoints.length === 0 && segmentIdx > 0) {\n        segmentIdx--;\n        syncPoints = this._list[segmentIdx].syncPoints;\n      }\n\n      if (syncPoints.length > 0) {\n        return syncPoints[syncPoints.length - 1];\n      } else {\n        return null;\n      }\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this._type;\n    }\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this._list.length;\n    }\n  }]);\n\n  return MediaSegmentInfoList;\n}();","map":null,"metadata":{},"sourceType":"module"}