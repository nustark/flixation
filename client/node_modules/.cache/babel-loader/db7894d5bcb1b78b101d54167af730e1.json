{"ast":null,"code":"import _classCallCheck from \"/Users/thurman/CS/React/streams/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/thurman/CS/React/streams/client/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport EventEmitter from 'events';\nimport Log from '../utils/logger.js';\nimport Browser from '../utils/browser.js';\nimport MediaInfo from './media-info.js';\nimport FLVDemuxer from '../demux/flv-demuxer.js';\nimport MP4Remuxer from '../remux/mp4-remuxer.js';\nimport DemuxErrors from '../demux/demux-errors.js';\nimport IOController from '../io/io-controller.js';\nimport TransmuxingEvents from './transmuxing-events.js';\nimport { LoaderStatus, LoaderErrors } from '../io/loader.js'; // Transmuxing (IO, Demuxing, Remuxing) controller, with multipart support\n\nvar TransmuxingController =\n/*#__PURE__*/\nfunction () {\n  function TransmuxingController(mediaDataSource, config) {\n    _classCallCheck(this, TransmuxingController);\n\n    this.TAG = 'TransmuxingController';\n    this._emitter = new EventEmitter();\n    this._config = config; // treat single part media as multipart media, which has only one segment\n\n    if (!mediaDataSource.segments) {\n      mediaDataSource.segments = [{\n        duration: mediaDataSource.duration,\n        filesize: mediaDataSource.filesize,\n        url: mediaDataSource.url\n      }];\n    } // fill in default IO params if not exists\n\n\n    if (typeof mediaDataSource.cors !== 'boolean') {\n      mediaDataSource.cors = true;\n    }\n\n    if (typeof mediaDataSource.withCredentials !== 'boolean') {\n      mediaDataSource.withCredentials = false;\n    }\n\n    this._mediaDataSource = mediaDataSource;\n    this._currentSegmentIndex = 0;\n    var totalDuration = 0;\n\n    this._mediaDataSource.segments.forEach(function (segment) {\n      // timestampBase for each segment, and calculate total duration\n      segment.timestampBase = totalDuration;\n      totalDuration += segment.duration; // params needed by IOController\n\n      segment.cors = mediaDataSource.cors;\n      segment.withCredentials = mediaDataSource.withCredentials; // referrer policy control, if exist\n\n      if (config.referrerPolicy) {\n        segment.referrerPolicy = config.referrerPolicy;\n      }\n    });\n\n    if (!isNaN(totalDuration) && this._mediaDataSource.duration !== totalDuration) {\n      this._mediaDataSource.duration = totalDuration;\n    }\n\n    this._mediaInfo = null;\n    this._demuxer = null;\n    this._remuxer = null;\n    this._ioctl = null;\n    this._pendingSeekTime = null;\n    this._pendingResolveSeekPoint = null;\n    this._statisticsReporter = null;\n  }\n\n  _createClass(TransmuxingController, [{\n    key: \"destroy\",\n    value: function destroy() {\n      this._mediaInfo = null;\n      this._mediaDataSource = null;\n\n      if (this._statisticsReporter) {\n        this._disableStatisticsReporter();\n      }\n\n      if (this._ioctl) {\n        this._ioctl.destroy();\n\n        this._ioctl = null;\n      }\n\n      if (this._demuxer) {\n        this._demuxer.destroy();\n\n        this._demuxer = null;\n      }\n\n      if (this._remuxer) {\n        this._remuxer.destroy();\n\n        this._remuxer = null;\n      }\n\n      this._emitter.removeAllListeners();\n\n      this._emitter = null;\n    }\n  }, {\n    key: \"on\",\n    value: function on(event, listener) {\n      this._emitter.addListener(event, listener);\n    }\n  }, {\n    key: \"off\",\n    value: function off(event, listener) {\n      this._emitter.removeListener(event, listener);\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      this._loadSegment(0);\n\n      this._enableStatisticsReporter();\n    }\n  }, {\n    key: \"_loadSegment\",\n    value: function _loadSegment(segmentIndex, optionalFrom) {\n      this._currentSegmentIndex = segmentIndex;\n      var dataSource = this._mediaDataSource.segments[segmentIndex];\n      var ioctl = this._ioctl = new IOController(dataSource, this._config, segmentIndex);\n      ioctl.onError = this._onIOException.bind(this);\n      ioctl.onSeeked = this._onIOSeeked.bind(this);\n      ioctl.onComplete = this._onIOComplete.bind(this);\n      ioctl.onRedirect = this._onIORedirect.bind(this);\n      ioctl.onRecoveredEarlyEof = this._onIORecoveredEarlyEof.bind(this);\n\n      if (optionalFrom) {\n        this._demuxer.bindDataSource(this._ioctl);\n      } else {\n        ioctl.onDataArrival = this._onInitChunkArrival.bind(this);\n      }\n\n      ioctl.open(optionalFrom);\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this._internalAbort();\n\n      this._disableStatisticsReporter();\n    }\n  }, {\n    key: \"_internalAbort\",\n    value: function _internalAbort() {\n      if (this._ioctl) {\n        this._ioctl.destroy();\n\n        this._ioctl = null;\n      }\n    }\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      // take a rest\n      if (this._ioctl && this._ioctl.isWorking()) {\n        this._ioctl.pause();\n\n        this._disableStatisticsReporter();\n      }\n    }\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      if (this._ioctl && this._ioctl.isPaused()) {\n        this._ioctl.resume();\n\n        this._enableStatisticsReporter();\n      }\n    }\n  }, {\n    key: \"seek\",\n    value: function seek(milliseconds) {\n      if (this._mediaInfo == null || !this._mediaInfo.isSeekable()) {\n        return;\n      }\n\n      var targetSegmentIndex = this._searchSegmentIndexContains(milliseconds);\n\n      if (targetSegmentIndex === this._currentSegmentIndex) {\n        // intra-segment seeking\n        var segmentInfo = this._mediaInfo.segments[targetSegmentIndex];\n\n        if (segmentInfo == undefined) {\n          // current segment loading started, but mediainfo hasn't received yet\n          // wait for the metadata loaded, then seek to expected position\n          this._pendingSeekTime = milliseconds;\n        } else {\n          var keyframe = segmentInfo.getNearestKeyframe(milliseconds);\n\n          this._remuxer.seek(keyframe.milliseconds);\n\n          this._ioctl.seek(keyframe.fileposition); // Will be resolved in _onRemuxerMediaSegmentArrival()\n\n\n          this._pendingResolveSeekPoint = keyframe.milliseconds;\n        }\n      } else {\n        // cross-segment seeking\n        var targetSegmentInfo = this._mediaInfo.segments[targetSegmentIndex];\n\n        if (targetSegmentInfo == undefined) {\n          // target segment hasn't been loaded. We need metadata then seek to expected time\n          this._pendingSeekTime = milliseconds;\n\n          this._internalAbort();\n\n          this._remuxer.seek();\n\n          this._remuxer.insertDiscontinuity();\n\n          this._loadSegment(targetSegmentIndex); // Here we wait for the metadata loaded, then seek to expected position\n\n        } else {\n          // We have target segment's metadata, direct seek to target position\n          var _keyframe = targetSegmentInfo.getNearestKeyframe(milliseconds);\n\n          this._internalAbort();\n\n          this._remuxer.seek(milliseconds);\n\n          this._remuxer.insertDiscontinuity();\n\n          this._demuxer.resetMediaInfo();\n\n          this._demuxer.timestampBase = this._mediaDataSource.segments[targetSegmentIndex].timestampBase;\n\n          this._loadSegment(targetSegmentIndex, _keyframe.fileposition);\n\n          this._pendingResolveSeekPoint = _keyframe.milliseconds;\n\n          this._reportSegmentMediaInfo(targetSegmentIndex);\n        }\n      }\n\n      this._enableStatisticsReporter();\n    }\n  }, {\n    key: \"_searchSegmentIndexContains\",\n    value: function _searchSegmentIndexContains(milliseconds) {\n      var segments = this._mediaDataSource.segments;\n      var idx = segments.length - 1;\n\n      for (var i = 0; i < segments.length; i++) {\n        if (milliseconds < segments[i].timestampBase) {\n          idx = i - 1;\n          break;\n        }\n      }\n\n      return idx;\n    }\n  }, {\n    key: \"_onInitChunkArrival\",\n    value: function _onInitChunkArrival(data, byteStart) {\n      var _this = this;\n\n      var probeData = null;\n      var consumed = 0;\n\n      if (byteStart > 0) {\n        // IOController seeked immediately after opened, byteStart > 0 callback may received\n        this._demuxer.bindDataSource(this._ioctl);\n\n        this._demuxer.timestampBase = this._mediaDataSource.segments[this._currentSegmentIndex].timestampBase;\n        consumed = this._demuxer.parseChunks(data, byteStart);\n      } else if ((probeData = FLVDemuxer.probe(data)).match) {\n        // Always create new FLVDemuxer\n        this._demuxer = new FLVDemuxer(probeData, this._config);\n\n        if (!this._remuxer) {\n          this._remuxer = new MP4Remuxer(this._config);\n        }\n\n        var mds = this._mediaDataSource;\n\n        if (mds.duration != undefined && !isNaN(mds.duration)) {\n          this._demuxer.overridedDuration = mds.duration;\n        }\n\n        if (typeof mds.hasAudio === 'boolean') {\n          this._demuxer.overridedHasAudio = mds.hasAudio;\n        }\n\n        if (typeof mds.hasVideo === 'boolean') {\n          this._demuxer.overridedHasVideo = mds.hasVideo;\n        }\n\n        this._demuxer.timestampBase = mds.segments[this._currentSegmentIndex].timestampBase;\n        this._demuxer.onError = this._onDemuxException.bind(this);\n        this._demuxer.onMediaInfo = this._onMediaInfo.bind(this);\n        this._demuxer.onMetaDataArrived = this._onMetaDataArrived.bind(this);\n        this._demuxer.onScriptDataArrived = this._onScriptDataArrived.bind(this);\n\n        this._remuxer.bindDataSource(this._demuxer.bindDataSource(this._ioctl));\n\n        this._remuxer.onInitSegment = this._onRemuxerInitSegmentArrival.bind(this);\n        this._remuxer.onMediaSegment = this._onRemuxerMediaSegmentArrival.bind(this);\n        consumed = this._demuxer.parseChunks(data, byteStart);\n      } else {\n        probeData = null;\n        Log.e(this.TAG, 'Non-FLV, Unsupported media type!');\n        Promise.resolve().then(function () {\n          _this._internalAbort();\n        });\n\n        this._emitter.emit(TransmuxingEvents.DEMUX_ERROR, DemuxErrors.FORMAT_UNSUPPORTED, 'Non-FLV, Unsupported media type');\n\n        consumed = 0;\n      }\n\n      return consumed;\n    }\n  }, {\n    key: \"_onMediaInfo\",\n    value: function _onMediaInfo(mediaInfo) {\n      var _this2 = this;\n\n      if (this._mediaInfo == null) {\n        // Store first segment's mediainfo as global mediaInfo\n        this._mediaInfo = Object.assign({}, mediaInfo);\n        this._mediaInfo.keyframesIndex = null;\n        this._mediaInfo.segments = [];\n        this._mediaInfo.segmentCount = this._mediaDataSource.segments.length;\n        Object.setPrototypeOf(this._mediaInfo, MediaInfo.prototype);\n      }\n\n      var segmentInfo = Object.assign({}, mediaInfo);\n      Object.setPrototypeOf(segmentInfo, MediaInfo.prototype);\n      this._mediaInfo.segments[this._currentSegmentIndex] = segmentInfo; // notify mediaInfo update\n\n      this._reportSegmentMediaInfo(this._currentSegmentIndex);\n\n      if (this._pendingSeekTime != null) {\n        Promise.resolve().then(function () {\n          var target = _this2._pendingSeekTime;\n          _this2._pendingSeekTime = null;\n\n          _this2.seek(target);\n        });\n      }\n    }\n  }, {\n    key: \"_onMetaDataArrived\",\n    value: function _onMetaDataArrived(metadata) {\n      this._emitter.emit(TransmuxingEvents.METADATA_ARRIVED, metadata);\n    }\n  }, {\n    key: \"_onScriptDataArrived\",\n    value: function _onScriptDataArrived(data) {\n      this._emitter.emit(TransmuxingEvents.SCRIPTDATA_ARRIVED, data);\n    }\n  }, {\n    key: \"_onIOSeeked\",\n    value: function _onIOSeeked() {\n      this._remuxer.insertDiscontinuity();\n    }\n  }, {\n    key: \"_onIOComplete\",\n    value: function _onIOComplete(extraData) {\n      var segmentIndex = extraData;\n      var nextSegmentIndex = segmentIndex + 1;\n\n      if (nextSegmentIndex < this._mediaDataSource.segments.length) {\n        this._internalAbort();\n\n        this._remuxer.flushStashedSamples();\n\n        this._loadSegment(nextSegmentIndex);\n      } else {\n        this._remuxer.flushStashedSamples();\n\n        this._emitter.emit(TransmuxingEvents.LOADING_COMPLETE);\n\n        this._disableStatisticsReporter();\n      }\n    }\n  }, {\n    key: \"_onIORedirect\",\n    value: function _onIORedirect(redirectedURL) {\n      var segmentIndex = this._ioctl.extraData;\n      this._mediaDataSource.segments[segmentIndex].redirectedURL = redirectedURL;\n    }\n  }, {\n    key: \"_onIORecoveredEarlyEof\",\n    value: function _onIORecoveredEarlyEof() {\n      this._emitter.emit(TransmuxingEvents.RECOVERED_EARLY_EOF);\n    }\n  }, {\n    key: \"_onIOException\",\n    value: function _onIOException(type, info) {\n      Log.e(this.TAG, \"IOException: type = \".concat(type, \", code = \").concat(info.code, \", msg = \").concat(info.msg));\n\n      this._emitter.emit(TransmuxingEvents.IO_ERROR, type, info);\n\n      this._disableStatisticsReporter();\n    }\n  }, {\n    key: \"_onDemuxException\",\n    value: function _onDemuxException(type, info) {\n      Log.e(this.TAG, \"DemuxException: type = \".concat(type, \", info = \").concat(info));\n\n      this._emitter.emit(TransmuxingEvents.DEMUX_ERROR, type, info);\n    }\n  }, {\n    key: \"_onRemuxerInitSegmentArrival\",\n    value: function _onRemuxerInitSegmentArrival(type, initSegment) {\n      this._emitter.emit(TransmuxingEvents.INIT_SEGMENT, type, initSegment);\n    }\n  }, {\n    key: \"_onRemuxerMediaSegmentArrival\",\n    value: function _onRemuxerMediaSegmentArrival(type, mediaSegment) {\n      if (this._pendingSeekTime != null) {\n        // Media segments after new-segment cross-seeking should be dropped.\n        return;\n      }\n\n      this._emitter.emit(TransmuxingEvents.MEDIA_SEGMENT, type, mediaSegment); // Resolve pending seekPoint\n\n\n      if (this._pendingResolveSeekPoint != null && type === 'video') {\n        var syncPoints = mediaSegment.info.syncPoints;\n        var seekpoint = this._pendingResolveSeekPoint;\n        this._pendingResolveSeekPoint = null; // Safari: Pass PTS for recommend_seekpoint\n\n        if (Browser.safari && syncPoints.length > 0 && syncPoints[0].originalDts === seekpoint) {\n          seekpoint = syncPoints[0].pts;\n        } // else: use original DTS (keyframe.milliseconds)\n\n\n        this._emitter.emit(TransmuxingEvents.RECOMMEND_SEEKPOINT, seekpoint);\n      }\n    }\n  }, {\n    key: \"_enableStatisticsReporter\",\n    value: function _enableStatisticsReporter() {\n      if (this._statisticsReporter == null) {\n        this._statisticsReporter = self.setInterval(this._reportStatisticsInfo.bind(this), this._config.statisticsInfoReportInterval);\n      }\n    }\n  }, {\n    key: \"_disableStatisticsReporter\",\n    value: function _disableStatisticsReporter() {\n      if (this._statisticsReporter) {\n        self.clearInterval(this._statisticsReporter);\n        this._statisticsReporter = null;\n      }\n    }\n  }, {\n    key: \"_reportSegmentMediaInfo\",\n    value: function _reportSegmentMediaInfo(segmentIndex) {\n      var segmentInfo = this._mediaInfo.segments[segmentIndex];\n      var exportInfo = Object.assign({}, segmentInfo);\n      exportInfo.duration = this._mediaInfo.duration;\n      exportInfo.segmentCount = this._mediaInfo.segmentCount;\n      delete exportInfo.segments;\n      delete exportInfo.keyframesIndex;\n\n      this._emitter.emit(TransmuxingEvents.MEDIA_INFO, exportInfo);\n    }\n  }, {\n    key: \"_reportStatisticsInfo\",\n    value: function _reportStatisticsInfo() {\n      var info = {};\n      info.url = this._ioctl.currentURL;\n      info.hasRedirect = this._ioctl.hasRedirect;\n\n      if (info.hasRedirect) {\n        info.redirectedURL = this._ioctl.currentRedirectedURL;\n      }\n\n      info.speed = this._ioctl.currentSpeed;\n      info.loaderType = this._ioctl.loaderType;\n      info.currentSegmentIndex = this._currentSegmentIndex;\n      info.totalSegmentCount = this._mediaDataSource.segments.length;\n\n      this._emitter.emit(TransmuxingEvents.STATISTICS_INFO, info);\n    }\n  }]);\n\n  return TransmuxingController;\n}();\n\nexport default TransmuxingController;","map":null,"metadata":{},"sourceType":"module"}