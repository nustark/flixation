{"ast":null,"code":"import _classCallCheck from \"/Users/thurman/CS/React/streams/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _possibleConstructorReturn from \"/Users/thurman/CS/React/streams/client/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/thurman/CS/React/streams/client/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"/Users/thurman/CS/React/streams/client/node_modules/@babel/runtime/helpers/esm/get\";\nimport _createClass from \"/Users/thurman/CS/React/streams/client/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/thurman/CS/React/streams/client/node_modules/@babel/runtime/helpers/esm/inherits\";\n\n/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport Log from '../utils/logger.js';\nimport { BaseLoader, LoaderStatus, LoaderErrors } from './loader.js';\nimport { RuntimeException } from '../utils/exception.js';\n/* Notice: ms-stream may cause IE/Edge browser crash if seek too frequently!!!\n * The browser may crash in wininet.dll. Disable for now.\n *\n * For IE11/Edge browser by microsoft which supports `xhr.responseType = 'ms-stream'`\n * Notice that ms-stream API sucks. The buffer is always expanding along with downloading.\n *\n * We need to abort the xhr if buffer size exceeded limit size (e.g. 16 MiB), then do reconnect.\n * in order to release previous ArrayBuffer to avoid memory leak\n *\n * Otherwise, the ArrayBuffer will increase to a terrible size that equals final file size.\n */\n\nvar MSStreamLoader =\n/*#__PURE__*/\nfunction (_BaseLoader) {\n  _inherits(MSStreamLoader, _BaseLoader);\n\n  _createClass(MSStreamLoader, null, [{\n    key: \"isSupported\",\n    value: function isSupported() {\n      try {\n        if (typeof self.MSStream === 'undefined' || typeof self.MSStreamReader === 'undefined') {\n          return false;\n        }\n\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', 'https://example.com', true);\n        xhr.responseType = 'ms-stream';\n        return xhr.responseType === 'ms-stream';\n      } catch (e) {\n        Log.w('MSStreamLoader', e.message);\n        return false;\n      }\n    }\n  }]);\n\n  function MSStreamLoader(seekHandler, config) {\n    var _this;\n\n    _classCallCheck(this, MSStreamLoader);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MSStreamLoader).call(this, 'xhr-msstream-loader'));\n    _this.TAG = 'MSStreamLoader';\n    _this._seekHandler = seekHandler;\n    _this._config = config;\n    _this._needStash = true;\n    _this._xhr = null;\n    _this._reader = null; // MSStreamReader\n\n    _this._totalRange = null;\n    _this._currentRange = null;\n    _this._currentRequestURL = null;\n    _this._currentRedirectedURL = null;\n    _this._contentLength = null;\n    _this._receivedLength = 0;\n    _this._bufferLimit = 16 * 1024 * 1024; // 16MB\n\n    _this._lastTimeBufferSize = 0;\n    _this._isReconnecting = false;\n    return _this;\n  }\n\n  _createClass(MSStreamLoader, [{\n    key: \"destroy\",\n    value: function destroy() {\n      if (this.isWorking()) {\n        this.abort();\n      }\n\n      if (this._reader) {\n        this._reader.onprogress = null;\n        this._reader.onload = null;\n        this._reader.onerror = null;\n        this._reader = null;\n      }\n\n      if (this._xhr) {\n        this._xhr.onreadystatechange = null;\n        this._xhr = null;\n      }\n\n      _get(_getPrototypeOf(MSStreamLoader.prototype), \"destroy\", this).call(this);\n    }\n  }, {\n    key: \"open\",\n    value: function open(dataSource, range) {\n      this._internalOpen(dataSource, range, false);\n    }\n  }, {\n    key: \"_internalOpen\",\n    value: function _internalOpen(dataSource, range, isSubrange) {\n      this._dataSource = dataSource;\n\n      if (!isSubrange) {\n        this._totalRange = range;\n      } else {\n        this._currentRange = range;\n      }\n\n      var sourceURL = dataSource.url;\n\n      if (this._config.reuseRedirectedURL) {\n        if (this._currentRedirectedURL != undefined) {\n          sourceURL = this._currentRedirectedURL;\n        } else if (dataSource.redirectedURL != undefined) {\n          sourceURL = dataSource.redirectedURL;\n        }\n      }\n\n      var seekConfig = this._seekHandler.getConfig(sourceURL, range);\n\n      this._currentRequestURL = seekConfig.url;\n      var reader = this._reader = new self.MSStreamReader();\n      reader.onprogress = this._msrOnProgress.bind(this);\n      reader.onload = this._msrOnLoad.bind(this);\n      reader.onerror = this._msrOnError.bind(this);\n      var xhr = this._xhr = new XMLHttpRequest();\n      xhr.open('GET', seekConfig.url, true);\n      xhr.responseType = 'ms-stream';\n      xhr.onreadystatechange = this._xhrOnReadyStateChange.bind(this);\n      xhr.onerror = this._xhrOnError.bind(this);\n\n      if (dataSource.withCredentials) {\n        xhr.withCredentials = true;\n      }\n\n      if (typeof seekConfig.headers === 'object') {\n        var headers = seekConfig.headers;\n\n        for (var key in headers) {\n          if (headers.hasOwnProperty(key)) {\n            xhr.setRequestHeader(key, headers[key]);\n          }\n        }\n      } // add additional headers\n\n\n      if (typeof this._config.headers === 'object') {\n        var _headers = this._config.headers;\n\n        for (var _key in _headers) {\n          if (_headers.hasOwnProperty(_key)) {\n            xhr.setRequestHeader(_key, _headers[_key]);\n          }\n        }\n      }\n\n      if (this._isReconnecting) {\n        this._isReconnecting = false;\n      } else {\n        this._status = LoaderStatus.kConnecting;\n      }\n\n      xhr.send();\n    }\n  }, {\n    key: \"abort\",\n    value: function abort() {\n      this._internalAbort();\n\n      this._status = LoaderStatus.kComplete;\n    }\n  }, {\n    key: \"_internalAbort\",\n    value: function _internalAbort() {\n      if (this._reader) {\n        if (this._reader.readyState === 1) {\n          // LOADING\n          this._reader.abort();\n        }\n\n        this._reader.onprogress = null;\n        this._reader.onload = null;\n        this._reader.onerror = null;\n        this._reader = null;\n      }\n\n      if (this._xhr) {\n        this._xhr.abort();\n\n        this._xhr.onreadystatechange = null;\n        this._xhr = null;\n      }\n    }\n  }, {\n    key: \"_xhrOnReadyStateChange\",\n    value: function _xhrOnReadyStateChange(e) {\n      var xhr = e.target;\n\n      if (xhr.readyState === 2) {\n        // HEADERS_RECEIVED\n        if (xhr.status >= 200 && xhr.status <= 299) {\n          this._status = LoaderStatus.kBuffering;\n\n          if (xhr.responseURL != undefined) {\n            var redirectedURL = this._seekHandler.removeURLParameters(xhr.responseURL);\n\n            if (xhr.responseURL !== this._currentRequestURL && redirectedURL !== this._currentRedirectedURL) {\n              this._currentRedirectedURL = redirectedURL;\n\n              if (this._onURLRedirect) {\n                this._onURLRedirect(redirectedURL);\n              }\n            }\n          }\n\n          var lengthHeader = xhr.getResponseHeader('Content-Length');\n\n          if (lengthHeader != null && this._contentLength == null) {\n            var length = parseInt(lengthHeader);\n\n            if (length > 0) {\n              this._contentLength = length;\n\n              if (this._onContentLengthKnown) {\n                this._onContentLengthKnown(this._contentLength);\n              }\n            }\n          }\n        } else {\n          this._status = LoaderStatus.kError;\n\n          if (this._onError) {\n            this._onError(LoaderErrors.HTTP_STATUS_CODE_INVALID, {\n              code: xhr.status,\n              msg: xhr.statusText\n            });\n          } else {\n            throw new RuntimeException('MSStreamLoader: Http code invalid, ' + xhr.status + ' ' + xhr.statusText);\n          }\n        }\n      } else if (xhr.readyState === 3) {\n        // LOADING\n        if (xhr.status >= 200 && xhr.status <= 299) {\n          this._status = LoaderStatus.kBuffering;\n          var msstream = xhr.response;\n\n          this._reader.readAsArrayBuffer(msstream);\n        }\n      }\n    }\n  }, {\n    key: \"_xhrOnError\",\n    value: function _xhrOnError(e) {\n      this._status = LoaderStatus.kError;\n      var type = LoaderErrors.EXCEPTION;\n      var info = {\n        code: -1,\n        msg: e.constructor.name + ' ' + e.type\n      };\n\n      if (this._onError) {\n        this._onError(type, info);\n      } else {\n        throw new RuntimeException(info.msg);\n      }\n    }\n  }, {\n    key: \"_msrOnProgress\",\n    value: function _msrOnProgress(e) {\n      var reader = e.target;\n      var bigbuffer = reader.result;\n\n      if (bigbuffer == null) {\n        // result may be null, workaround for buggy M$\n        this._doReconnectIfNeeded();\n\n        return;\n      }\n\n      var slice = bigbuffer.slice(this._lastTimeBufferSize);\n      this._lastTimeBufferSize = bigbuffer.byteLength;\n      var byteStart = this._totalRange.from + this._receivedLength;\n      this._receivedLength += slice.byteLength;\n\n      if (this._onDataArrival) {\n        this._onDataArrival(slice, byteStart, this._receivedLength);\n      }\n\n      if (bigbuffer.byteLength >= this._bufferLimit) {\n        Log.v(this.TAG, \"MSStream buffer exceeded max size near \".concat(byteStart + slice.byteLength, \", reconnecting...\"));\n\n        this._doReconnectIfNeeded();\n      }\n    }\n  }, {\n    key: \"_doReconnectIfNeeded\",\n    value: function _doReconnectIfNeeded() {\n      if (this._contentLength == null || this._receivedLength < this._contentLength) {\n        this._isReconnecting = true;\n        this._lastTimeBufferSize = 0;\n\n        this._internalAbort();\n\n        var range = {\n          from: this._totalRange.from + this._receivedLength,\n          to: -1\n        };\n\n        this._internalOpen(this._dataSource, range, true);\n      }\n    }\n  }, {\n    key: \"_msrOnLoad\",\n    value: function _msrOnLoad(e) {\n      // actually it is onComplete event\n      this._status = LoaderStatus.kComplete;\n\n      if (this._onComplete) {\n        this._onComplete(this._totalRange.from, this._totalRange.from + this._receivedLength - 1);\n      }\n    }\n  }, {\n    key: \"_msrOnError\",\n    value: function _msrOnError(e) {\n      this._status = LoaderStatus.kError;\n      var type = 0;\n      var info = null;\n\n      if (this._contentLength && this._receivedLength < this._contentLength) {\n        type = LoaderErrors.EARLY_EOF;\n        info = {\n          code: -1,\n          msg: 'MSStream meet Early-Eof'\n        };\n      } else {\n        type = LoaderErrors.EARLY_EOF;\n        info = {\n          code: -1,\n          msg: e.constructor.name + ' ' + e.type\n        };\n      }\n\n      if (this._onError) {\n        this._onError(type, info);\n      } else {\n        throw new RuntimeException(info.msg);\n      }\n    }\n  }]);\n\n  return MSStreamLoader;\n}(BaseLoader);\n\nexport default MSStreamLoader;","map":null,"metadata":{},"sourceType":"module"}