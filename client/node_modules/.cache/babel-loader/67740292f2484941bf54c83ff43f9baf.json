{"ast":null,"code":"import _classCallCheck from \"/Users/thurman/CS/React/streams/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/thurman/CS/React/streams/client/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport Log from '../utils/logger.js';\nimport AMF from './amf-parser.js';\nimport SPSParser from './sps-parser.js';\nimport DemuxErrors from './demux-errors.js';\nimport MediaInfo from '../core/media-info.js';\nimport { IllegalStateException } from '../utils/exception.js';\n\nfunction Swap16(src) {\n  return src >>> 8 & 0xFF | (src & 0xFF) << 8;\n}\n\nfunction Swap32(src) {\n  return (src & 0xFF000000) >>> 24 | (src & 0x00FF0000) >>> 8 | (src & 0x0000FF00) << 8 | (src & 0x000000FF) << 24;\n}\n\nfunction ReadBig32(array, index) {\n  return array[index] << 24 | array[index + 1] << 16 | array[index + 2] << 8 | array[index + 3];\n}\n\nvar FLVDemuxer =\n/*#__PURE__*/\nfunction () {\n  function FLVDemuxer(probeData, config) {\n    _classCallCheck(this, FLVDemuxer);\n\n    this.TAG = 'FLVDemuxer';\n    this._config = config;\n    this._onError = null;\n    this._onMediaInfo = null;\n    this._onMetaDataArrived = null;\n    this._onScriptDataArrived = null;\n    this._onTrackMetadata = null;\n    this._onDataAvailable = null;\n    this._dataOffset = probeData.dataOffset;\n    this._firstParse = true;\n    this._dispatch = false;\n    this._hasAudio = probeData.hasAudioTrack;\n    this._hasVideo = probeData.hasVideoTrack;\n    this._hasAudioFlagOverrided = false;\n    this._hasVideoFlagOverrided = false;\n    this._audioInitialMetadataDispatched = false;\n    this._videoInitialMetadataDispatched = false;\n    this._mediaInfo = new MediaInfo();\n    this._mediaInfo.hasAudio = this._hasAudio;\n    this._mediaInfo.hasVideo = this._hasVideo;\n    this._metadata = null;\n    this._audioMetadata = null;\n    this._videoMetadata = null;\n    this._naluLengthSize = 4;\n    this._timestampBase = 0; // int32, in milliseconds\n\n    this._timescale = 1000;\n    this._duration = 0; // int32, in milliseconds\n\n    this._durationOverrided = false;\n    this._referenceFrameRate = {\n      fixed: true,\n      fps: 23.976,\n      fps_num: 23976,\n      fps_den: 1000\n    };\n    this._flvSoundRateTable = [5500, 11025, 22050, 44100, 48000];\n    this._mpegSamplingRates = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];\n    this._mpegAudioV10SampleRateTable = [44100, 48000, 32000, 0];\n    this._mpegAudioV20SampleRateTable = [22050, 24000, 16000, 0];\n    this._mpegAudioV25SampleRateTable = [11025, 12000, 8000, 0];\n    this._mpegAudioL1BitRateTable = [0, 32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, -1];\n    this._mpegAudioL2BitRateTable = [0, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, -1];\n    this._mpegAudioL3BitRateTable = [0, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, -1];\n    this._videoTrack = {\n      type: 'video',\n      id: 1,\n      sequenceNumber: 0,\n      samples: [],\n      length: 0\n    };\n    this._audioTrack = {\n      type: 'audio',\n      id: 2,\n      sequenceNumber: 0,\n      samples: [],\n      length: 0\n    };\n\n    this._littleEndian = function () {\n      var buf = new ArrayBuffer(2);\n      new DataView(buf).setInt16(0, 256, true); // little-endian write\n\n      return new Int16Array(buf)[0] === 256; // platform-spec read, if equal then LE\n    }();\n  }\n\n  _createClass(FLVDemuxer, [{\n    key: \"destroy\",\n    value: function destroy() {\n      this._mediaInfo = null;\n      this._metadata = null;\n      this._audioMetadata = null;\n      this._videoMetadata = null;\n      this._videoTrack = null;\n      this._audioTrack = null;\n      this._onError = null;\n      this._onMediaInfo = null;\n      this._onMetaDataArrived = null;\n      this._onScriptDataArrived = null;\n      this._onTrackMetadata = null;\n      this._onDataAvailable = null;\n    }\n  }, {\n    key: \"bindDataSource\",\n    value: function bindDataSource(loader) {\n      loader.onDataArrival = this.parseChunks.bind(this);\n      return this;\n    } // prototype: function(type: string, metadata: any): void\n\n  }, {\n    key: \"resetMediaInfo\",\n    value: function resetMediaInfo() {\n      this._mediaInfo = new MediaInfo();\n    }\n  }, {\n    key: \"_isInitialMetadataDispatched\",\n    value: function _isInitialMetadataDispatched() {\n      if (this._hasAudio && this._hasVideo) {\n        // both audio & video\n        return this._audioInitialMetadataDispatched && this._videoInitialMetadataDispatched;\n      }\n\n      if (this._hasAudio && !this._hasVideo) {\n        // audio only\n        return this._audioInitialMetadataDispatched;\n      }\n\n      if (!this._hasAudio && this._hasVideo) {\n        // video only\n        return this._videoInitialMetadataDispatched;\n      }\n\n      return false;\n    } // function parseChunks(chunk: ArrayBuffer, byteStart: number): number;\n\n  }, {\n    key: \"parseChunks\",\n    value: function parseChunks(chunk, byteStart) {\n      if (!this._onError || !this._onMediaInfo || !this._onTrackMetadata || !this._onDataAvailable) {\n        throw new IllegalStateException('Flv: onError & onMediaInfo & onTrackMetadata & onDataAvailable callback must be specified');\n      }\n\n      var offset = 0;\n      var le = this._littleEndian;\n\n      if (byteStart === 0) {\n        // buffer with FLV header\n        if (chunk.byteLength > 13) {\n          var probeData = FLVDemuxer.probe(chunk);\n          offset = probeData.dataOffset;\n        } else {\n          return 0;\n        }\n      }\n\n      if (this._firstParse) {\n        // handle PreviousTagSize0 before Tag1\n        this._firstParse = false;\n\n        if (byteStart + offset !== this._dataOffset) {\n          Log.w(this.TAG, 'First time parsing but chunk byteStart invalid!');\n        }\n\n        var v = new DataView(chunk, offset);\n        var prevTagSize0 = v.getUint32(0, !le);\n\n        if (prevTagSize0 !== 0) {\n          Log.w(this.TAG, 'PrevTagSize0 !== 0 !!!');\n        }\n\n        offset += 4;\n      }\n\n      while (offset < chunk.byteLength) {\n        this._dispatch = true;\n\n        var _v = new DataView(chunk, offset);\n\n        if (offset + 11 + 4 > chunk.byteLength) {\n          // data not enough for parsing an flv tag\n          break;\n        }\n\n        var tagType = _v.getUint8(0);\n\n        var dataSize = _v.getUint32(0, !le) & 0x00FFFFFF;\n\n        if (offset + 11 + dataSize + 4 > chunk.byteLength) {\n          // data not enough for parsing actual data body\n          break;\n        }\n\n        if (tagType !== 8 && tagType !== 9 && tagType !== 18) {\n          Log.w(this.TAG, \"Unsupported tag type \".concat(tagType, \", skipped\")); // consume the whole tag (skip it)\n\n          offset += 11 + dataSize + 4;\n          continue;\n        }\n\n        var ts2 = _v.getUint8(4);\n\n        var ts1 = _v.getUint8(5);\n\n        var ts0 = _v.getUint8(6);\n\n        var ts3 = _v.getUint8(7);\n\n        var timestamp = ts0 | ts1 << 8 | ts2 << 16 | ts3 << 24;\n        var streamId = _v.getUint32(7, !le) & 0x00FFFFFF;\n\n        if (streamId !== 0) {\n          Log.w(this.TAG, 'Meet tag which has StreamID != 0!');\n        }\n\n        var dataOffset = offset + 11;\n\n        switch (tagType) {\n          case 8:\n            // Audio\n            this._parseAudioData(chunk, dataOffset, dataSize, timestamp);\n\n            break;\n\n          case 9:\n            // Video\n            this._parseVideoData(chunk, dataOffset, dataSize, timestamp, byteStart + offset);\n\n            break;\n\n          case 18:\n            // ScriptDataObject\n            this._parseScriptData(chunk, dataOffset, dataSize);\n\n            break;\n        }\n\n        var prevTagSize = _v.getUint32(11 + dataSize, !le);\n\n        if (prevTagSize !== 11 + dataSize) {\n          Log.w(this.TAG, \"Invalid PrevTagSize \".concat(prevTagSize));\n        }\n\n        offset += 11 + dataSize + 4; // tagBody + dataSize + prevTagSize\n      } // dispatch parsed frames to consumer (typically, the remuxer)\n\n\n      if (this._isInitialMetadataDispatched()) {\n        if (this._dispatch && (this._audioTrack.length || this._videoTrack.length)) {\n          this._onDataAvailable(this._audioTrack, this._videoTrack);\n        }\n      }\n\n      return offset; // consumed bytes, just equals latest offset index\n    }\n  }, {\n    key: \"_parseScriptData\",\n    value: function _parseScriptData(arrayBuffer, dataOffset, dataSize) {\n      var scriptData = AMF.parseScriptData(arrayBuffer, dataOffset, dataSize);\n\n      if (scriptData.hasOwnProperty('onMetaData')) {\n        if (scriptData.onMetaData == null || typeof scriptData.onMetaData !== 'object') {\n          Log.w(this.TAG, 'Invalid onMetaData structure!');\n          return;\n        }\n\n        if (this._metadata) {\n          Log.w(this.TAG, 'Found another onMetaData tag!');\n        }\n\n        this._metadata = scriptData;\n        var onMetaData = this._metadata.onMetaData;\n\n        if (this._onMetaDataArrived) {\n          this._onMetaDataArrived(Object.assign({}, onMetaData));\n        }\n\n        if (typeof onMetaData.hasAudio === 'boolean') {\n          // hasAudio\n          if (this._hasAudioFlagOverrided === false) {\n            this._hasAudio = onMetaData.hasAudio;\n            this._mediaInfo.hasAudio = this._hasAudio;\n          }\n        }\n\n        if (typeof onMetaData.hasVideo === 'boolean') {\n          // hasVideo\n          if (this._hasVideoFlagOverrided === false) {\n            this._hasVideo = onMetaData.hasVideo;\n            this._mediaInfo.hasVideo = this._hasVideo;\n          }\n        }\n\n        if (typeof onMetaData.audiodatarate === 'number') {\n          // audiodatarate\n          this._mediaInfo.audioDataRate = onMetaData.audiodatarate;\n        }\n\n        if (typeof onMetaData.videodatarate === 'number') {\n          // videodatarate\n          this._mediaInfo.videoDataRate = onMetaData.videodatarate;\n        }\n\n        if (typeof onMetaData.width === 'number') {\n          // width\n          this._mediaInfo.width = onMetaData.width;\n        }\n\n        if (typeof onMetaData.height === 'number') {\n          // height\n          this._mediaInfo.height = onMetaData.height;\n        }\n\n        if (typeof onMetaData.duration === 'number') {\n          // duration\n          if (!this._durationOverrided) {\n            var duration = Math.floor(onMetaData.duration * this._timescale);\n            this._duration = duration;\n            this._mediaInfo.duration = duration;\n          }\n        } else {\n          this._mediaInfo.duration = 0;\n        }\n\n        if (typeof onMetaData.framerate === 'number') {\n          // framerate\n          var fps_num = Math.floor(onMetaData.framerate * 1000);\n\n          if (fps_num > 0) {\n            var fps = fps_num / 1000;\n            this._referenceFrameRate.fixed = true;\n            this._referenceFrameRate.fps = fps;\n            this._referenceFrameRate.fps_num = fps_num;\n            this._referenceFrameRate.fps_den = 1000;\n            this._mediaInfo.fps = fps;\n          }\n        }\n\n        if (typeof onMetaData.keyframes === 'object') {\n          // keyframes\n          this._mediaInfo.hasKeyframesIndex = true;\n          var keyframes = onMetaData.keyframes;\n          this._mediaInfo.keyframesIndex = this._parseKeyframesIndex(keyframes);\n          onMetaData.keyframes = null; // keyframes has been extracted, remove it\n        } else {\n          this._mediaInfo.hasKeyframesIndex = false;\n        }\n\n        this._dispatch = false;\n        this._mediaInfo.metadata = onMetaData;\n        Log.v(this.TAG, 'Parsed onMetaData');\n\n        if (this._mediaInfo.isComplete()) {\n          this._onMediaInfo(this._mediaInfo);\n        }\n      }\n\n      if (Object.keys(scriptData).length > 0) {\n        if (this._onScriptDataArrived) {\n          this._onScriptDataArrived(Object.assign({}, scriptData));\n        }\n      }\n    }\n  }, {\n    key: \"_parseKeyframesIndex\",\n    value: function _parseKeyframesIndex(keyframes) {\n      var times = [];\n      var filepositions = []; // ignore first keyframe which is actually AVC Sequence Header (AVCDecoderConfigurationRecord)\n\n      for (var i = 1; i < keyframes.times.length; i++) {\n        var time = this._timestampBase + Math.floor(keyframes.times[i] * 1000);\n        times.push(time);\n        filepositions.push(keyframes.filepositions[i]);\n      }\n\n      return {\n        times: times,\n        filepositions: filepositions\n      };\n    }\n  }, {\n    key: \"_parseAudioData\",\n    value: function _parseAudioData(arrayBuffer, dataOffset, dataSize, tagTimestamp) {\n      if (dataSize <= 1) {\n        Log.w(this.TAG, 'Flv: Invalid audio packet, missing SoundData payload!');\n        return;\n      }\n\n      if (this._hasAudioFlagOverrided === true && this._hasAudio === false) {\n        // If hasAudio: false indicated explicitly in MediaDataSource,\n        // Ignore all the audio packets\n        return;\n      }\n\n      var le = this._littleEndian;\n      var v = new DataView(arrayBuffer, dataOffset, dataSize);\n      var soundSpec = v.getUint8(0);\n      var soundFormat = soundSpec >>> 4;\n\n      if (soundFormat !== 2 && soundFormat !== 10) {\n        // MP3 or AAC\n        this._onError(DemuxErrors.CODEC_UNSUPPORTED, 'Flv: Unsupported audio codec idx: ' + soundFormat);\n\n        return;\n      }\n\n      var soundRate = 0;\n      var soundRateIndex = (soundSpec & 12) >>> 2;\n\n      if (soundRateIndex >= 0 && soundRateIndex <= 4) {\n        soundRate = this._flvSoundRateTable[soundRateIndex];\n      } else {\n        this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: Invalid audio sample rate idx: ' + soundRateIndex);\n\n        return;\n      }\n\n      var soundSize = (soundSpec & 2) >>> 1; // unused\n\n      var soundType = soundSpec & 1;\n      var meta = this._audioMetadata;\n      var track = this._audioTrack;\n\n      if (!meta) {\n        if (this._hasAudio === false && this._hasAudioFlagOverrided === false) {\n          this._hasAudio = true;\n          this._mediaInfo.hasAudio = true;\n        } // initial metadata\n\n\n        meta = this._audioMetadata = {};\n        meta.type = 'audio';\n        meta.id = track.id;\n        meta.timescale = this._timescale;\n        meta.duration = this._duration;\n        meta.audioSampleRate = soundRate;\n        meta.channelCount = soundType === 0 ? 1 : 2;\n      }\n\n      if (soundFormat === 10) {\n        // AAC\n        var aacData = this._parseAACAudioData(arrayBuffer, dataOffset + 1, dataSize - 1);\n\n        if (aacData == undefined) {\n          return;\n        }\n\n        if (aacData.packetType === 0) {\n          // AAC sequence header (AudioSpecificConfig)\n          if (meta.config) {\n            Log.w(this.TAG, 'Found another AudioSpecificConfig!');\n          }\n\n          var misc = aacData.data;\n          meta.audioSampleRate = misc.samplingRate;\n          meta.channelCount = misc.channelCount;\n          meta.codec = misc.codec;\n          meta.originalCodec = misc.originalCodec;\n          meta.config = misc.config; // The decode result of an aac sample is 1024 PCM samples\n\n          meta.refSampleDuration = 1024 / meta.audioSampleRate * meta.timescale;\n          Log.v(this.TAG, 'Parsed AudioSpecificConfig');\n\n          if (this._isInitialMetadataDispatched()) {\n            // Non-initial metadata, force dispatch (or flush) parsed frames to remuxer\n            if (this._dispatch && (this._audioTrack.length || this._videoTrack.length)) {\n              this._onDataAvailable(this._audioTrack, this._videoTrack);\n            }\n          } else {\n            this._audioInitialMetadataDispatched = true;\n          } // then notify new metadata\n\n\n          this._dispatch = false;\n\n          this._onTrackMetadata('audio', meta);\n\n          var mi = this._mediaInfo;\n          mi.audioCodec = meta.originalCodec;\n          mi.audioSampleRate = meta.audioSampleRate;\n          mi.audioChannelCount = meta.channelCount;\n\n          if (mi.hasVideo) {\n            if (mi.videoCodec != null) {\n              mi.mimeType = 'video/x-flv; codecs=\"' + mi.videoCodec + ',' + mi.audioCodec + '\"';\n            }\n          } else {\n            mi.mimeType = 'video/x-flv; codecs=\"' + mi.audioCodec + '\"';\n          }\n\n          if (mi.isComplete()) {\n            this._onMediaInfo(mi);\n          }\n        } else if (aacData.packetType === 1) {\n          // AAC raw frame data\n          var dts = this._timestampBase + tagTimestamp;\n          var aacSample = {\n            unit: aacData.data,\n            length: aacData.data.byteLength,\n            dts: dts,\n            pts: dts\n          };\n          track.samples.push(aacSample);\n          track.length += aacData.data.length;\n        } else {\n          Log.e(this.TAG, \"Flv: Unsupported AAC data type \".concat(aacData.packetType));\n        }\n      } else if (soundFormat === 2) {\n        // MP3\n        if (!meta.codec) {\n          // We need metadata for mp3 audio track, extract info from frame header\n          var _misc = this._parseMP3AudioData(arrayBuffer, dataOffset + 1, dataSize - 1, true);\n\n          if (_misc == undefined) {\n            return;\n          }\n\n          meta.audioSampleRate = _misc.samplingRate;\n          meta.channelCount = _misc.channelCount;\n          meta.codec = _misc.codec;\n          meta.originalCodec = _misc.originalCodec; // The decode result of an mp3 sample is 1152 PCM samples\n\n          meta.refSampleDuration = 1152 / meta.audioSampleRate * meta.timescale;\n          Log.v(this.TAG, 'Parsed MPEG Audio Frame Header');\n          this._audioInitialMetadataDispatched = true;\n\n          this._onTrackMetadata('audio', meta);\n\n          var _mi = this._mediaInfo;\n          _mi.audioCodec = meta.codec;\n          _mi.audioSampleRate = meta.audioSampleRate;\n          _mi.audioChannelCount = meta.channelCount;\n          _mi.audioDataRate = _misc.bitRate;\n\n          if (_mi.hasVideo) {\n            if (_mi.videoCodec != null) {\n              _mi.mimeType = 'video/x-flv; codecs=\"' + _mi.videoCodec + ',' + _mi.audioCodec + '\"';\n            }\n          } else {\n            _mi.mimeType = 'video/x-flv; codecs=\"' + _mi.audioCodec + '\"';\n          }\n\n          if (_mi.isComplete()) {\n            this._onMediaInfo(_mi);\n          }\n        } // This packet is always a valid audio packet, extract it\n\n\n        var data = this._parseMP3AudioData(arrayBuffer, dataOffset + 1, dataSize - 1, false);\n\n        if (data == undefined) {\n          return;\n        }\n\n        var _dts = this._timestampBase + tagTimestamp;\n\n        var mp3Sample = {\n          unit: data,\n          length: data.byteLength,\n          dts: _dts,\n          pts: _dts\n        };\n        track.samples.push(mp3Sample);\n        track.length += data.length;\n      }\n    }\n  }, {\n    key: \"_parseAACAudioData\",\n    value: function _parseAACAudioData(arrayBuffer, dataOffset, dataSize) {\n      if (dataSize <= 1) {\n        Log.w(this.TAG, 'Flv: Invalid AAC packet, missing AACPacketType or/and Data!');\n        return;\n      }\n\n      var result = {};\n      var array = new Uint8Array(arrayBuffer, dataOffset, dataSize);\n      result.packetType = array[0];\n\n      if (array[0] === 0) {\n        result.data = this._parseAACAudioSpecificConfig(arrayBuffer, dataOffset + 1, dataSize - 1);\n      } else {\n        result.data = array.subarray(1);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_parseAACAudioSpecificConfig\",\n    value: function _parseAACAudioSpecificConfig(arrayBuffer, dataOffset, dataSize) {\n      var array = new Uint8Array(arrayBuffer, dataOffset, dataSize);\n      var config = null;\n      /* Audio Object Type:\n         0: Null\n         1: AAC Main\n         2: AAC LC\n         3: AAC SSR (Scalable Sample Rate)\n         4: AAC LTP (Long Term Prediction)\n         5: HE-AAC / SBR (Spectral Band Replication)\n         6: AAC Scalable\n      */\n\n      var audioObjectType = 0;\n      var originalAudioObjectType = 0;\n      var audioExtensionObjectType = null;\n      var samplingIndex = 0;\n      var extensionSamplingIndex = null; // 5 bits\n\n      audioObjectType = originalAudioObjectType = array[0] >>> 3; // 4 bits\n\n      samplingIndex = (array[0] & 0x07) << 1 | array[1] >>> 7;\n\n      if (samplingIndex < 0 || samplingIndex >= this._mpegSamplingRates.length) {\n        this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: AAC invalid sampling frequency index!');\n\n        return;\n      }\n\n      var samplingFrequence = this._mpegSamplingRates[samplingIndex]; // 4 bits\n\n      var channelConfig = (array[1] & 0x78) >>> 3;\n\n      if (channelConfig < 0 || channelConfig >= 8) {\n        this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: AAC invalid channel configuration');\n\n        return;\n      }\n\n      if (audioObjectType === 5) {\n        // HE-AAC?\n        // 4 bits\n        extensionSamplingIndex = (array[1] & 0x07) << 1 | array[2] >>> 7; // 5 bits\n\n        audioExtensionObjectType = (array[2] & 0x7C) >>> 2;\n      } // workarounds for various browsers\n\n\n      var userAgent = self.navigator.userAgent.toLowerCase();\n\n      if (userAgent.indexOf('firefox') !== -1) {\n        // firefox: use SBR (HE-AAC) if freq less than 24kHz\n        if (samplingIndex >= 6) {\n          audioObjectType = 5;\n          config = new Array(4);\n          extensionSamplingIndex = samplingIndex - 3;\n        } else {\n          // use LC-AAC\n          audioObjectType = 2;\n          config = new Array(2);\n          extensionSamplingIndex = samplingIndex;\n        }\n      } else if (userAgent.indexOf('android') !== -1) {\n        // android: always use LC-AAC\n        audioObjectType = 2;\n        config = new Array(2);\n        extensionSamplingIndex = samplingIndex;\n      } else {\n        // for other browsers, e.g. chrome...\n        // Always use HE-AAC to make it easier to switch aac codec profile\n        audioObjectType = 5;\n        extensionSamplingIndex = samplingIndex;\n        config = new Array(4);\n\n        if (samplingIndex >= 6) {\n          extensionSamplingIndex = samplingIndex - 3;\n        } else if (channelConfig === 1) {\n          // Mono channel\n          audioObjectType = 2;\n          config = new Array(2);\n          extensionSamplingIndex = samplingIndex;\n        }\n      }\n\n      config[0] = audioObjectType << 3;\n      config[0] |= (samplingIndex & 0x0F) >>> 1;\n      config[1] = (samplingIndex & 0x0F) << 7;\n      config[1] |= (channelConfig & 0x0F) << 3;\n\n      if (audioObjectType === 5) {\n        config[1] |= (extensionSamplingIndex & 0x0F) >>> 1;\n        config[2] = (extensionSamplingIndex & 0x01) << 7; // extended audio object type: force to 2 (LC-AAC)\n\n        config[2] |= 2 << 2;\n        config[3] = 0;\n      }\n\n      return {\n        config: config,\n        samplingRate: samplingFrequence,\n        channelCount: channelConfig,\n        codec: 'mp4a.40.' + audioObjectType,\n        originalCodec: 'mp4a.40.' + originalAudioObjectType\n      };\n    }\n  }, {\n    key: \"_parseMP3AudioData\",\n    value: function _parseMP3AudioData(arrayBuffer, dataOffset, dataSize, requestHeader) {\n      if (dataSize < 4) {\n        Log.w(this.TAG, 'Flv: Invalid MP3 packet, header missing!');\n        return;\n      }\n\n      var le = this._littleEndian;\n      var array = new Uint8Array(arrayBuffer, dataOffset, dataSize);\n      var result = null;\n\n      if (requestHeader) {\n        if (array[0] !== 0xFF) {\n          return;\n        }\n\n        var ver = array[1] >>> 3 & 0x03;\n        var layer = (array[1] & 0x06) >> 1;\n        var bitrate_index = (array[2] & 0xF0) >>> 4;\n        var sampling_freq_index = (array[2] & 0x0C) >>> 2;\n        var channel_mode = array[3] >>> 6 & 0x03;\n        var channel_count = channel_mode !== 3 ? 2 : 1;\n        var sample_rate = 0;\n        var bit_rate = 0;\n        var object_type = 34; // Layer-3, listed in MPEG-4 Audio Object Types\n\n        var codec = 'mp3';\n\n        switch (ver) {\n          case 0:\n            // MPEG 2.5\n            sample_rate = this._mpegAudioV25SampleRateTable[sampling_freq_index];\n            break;\n\n          case 2:\n            // MPEG 2\n            sample_rate = this._mpegAudioV20SampleRateTable[sampling_freq_index];\n            break;\n\n          case 3:\n            // MPEG 1\n            sample_rate = this._mpegAudioV10SampleRateTable[sampling_freq_index];\n            break;\n        }\n\n        switch (layer) {\n          case 1:\n            // Layer 3\n            object_type = 34;\n\n            if (bitrate_index < this._mpegAudioL3BitRateTable.length) {\n              bit_rate = this._mpegAudioL3BitRateTable[bitrate_index];\n            }\n\n            break;\n\n          case 2:\n            // Layer 2\n            object_type = 33;\n\n            if (bitrate_index < this._mpegAudioL2BitRateTable.length) {\n              bit_rate = this._mpegAudioL2BitRateTable[bitrate_index];\n            }\n\n            break;\n\n          case 3:\n            // Layer 1\n            object_type = 32;\n\n            if (bitrate_index < this._mpegAudioL1BitRateTable.length) {\n              bit_rate = this._mpegAudioL1BitRateTable[bitrate_index];\n            }\n\n            break;\n        }\n\n        result = {\n          bitRate: bit_rate,\n          samplingRate: sample_rate,\n          channelCount: channel_count,\n          codec: codec,\n          originalCodec: codec\n        };\n      } else {\n        result = array;\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_parseVideoData\",\n    value: function _parseVideoData(arrayBuffer, dataOffset, dataSize, tagTimestamp, tagPosition) {\n      if (dataSize <= 1) {\n        Log.w(this.TAG, 'Flv: Invalid video packet, missing VideoData payload!');\n        return;\n      }\n\n      if (this._hasVideoFlagOverrided === true && this._hasVideo === false) {\n        // If hasVideo: false indicated explicitly in MediaDataSource,\n        // Ignore all the video packets\n        return;\n      }\n\n      var spec = new Uint8Array(arrayBuffer, dataOffset, dataSize)[0];\n      var frameType = (spec & 240) >>> 4;\n      var codecId = spec & 15;\n\n      if (codecId !== 7) {\n        this._onError(DemuxErrors.CODEC_UNSUPPORTED, \"Flv: Unsupported codec in video frame: \".concat(codecId));\n\n        return;\n      }\n\n      this._parseAVCVideoPacket(arrayBuffer, dataOffset + 1, dataSize - 1, tagTimestamp, tagPosition, frameType);\n    }\n  }, {\n    key: \"_parseAVCVideoPacket\",\n    value: function _parseAVCVideoPacket(arrayBuffer, dataOffset, dataSize, tagTimestamp, tagPosition, frameType) {\n      if (dataSize < 4) {\n        Log.w(this.TAG, 'Flv: Invalid AVC packet, missing AVCPacketType or/and CompositionTime');\n        return;\n      }\n\n      var le = this._littleEndian;\n      var v = new DataView(arrayBuffer, dataOffset, dataSize);\n      var packetType = v.getUint8(0);\n      var cts_unsigned = v.getUint32(0, !le) & 0x00FFFFFF;\n      var cts = cts_unsigned << 8 >> 8; // convert to 24-bit signed int\n\n      if (packetType === 0) {\n        // AVCDecoderConfigurationRecord\n        this._parseAVCDecoderConfigurationRecord(arrayBuffer, dataOffset + 4, dataSize - 4);\n      } else if (packetType === 1) {\n        // One or more Nalus\n        this._parseAVCVideoData(arrayBuffer, dataOffset + 4, dataSize - 4, tagTimestamp, tagPosition, frameType, cts);\n      } else if (packetType === 2) {// empty, AVC end of sequence\n      } else {\n        this._onError(DemuxErrors.FORMAT_ERROR, \"Flv: Invalid video packet type \".concat(packetType));\n\n        return;\n      }\n    }\n  }, {\n    key: \"_parseAVCDecoderConfigurationRecord\",\n    value: function _parseAVCDecoderConfigurationRecord(arrayBuffer, dataOffset, dataSize) {\n      if (dataSize < 7) {\n        Log.w(this.TAG, 'Flv: Invalid AVCDecoderConfigurationRecord, lack of data!');\n        return;\n      }\n\n      var meta = this._videoMetadata;\n      var track = this._videoTrack;\n      var le = this._littleEndian;\n      var v = new DataView(arrayBuffer, dataOffset, dataSize);\n\n      if (!meta) {\n        if (this._hasVideo === false && this._hasVideoFlagOverrided === false) {\n          this._hasVideo = true;\n          this._mediaInfo.hasVideo = true;\n        }\n\n        meta = this._videoMetadata = {};\n        meta.type = 'video';\n        meta.id = track.id;\n        meta.timescale = this._timescale;\n        meta.duration = this._duration;\n      } else {\n        if (typeof meta.avcc !== 'undefined') {\n          Log.w(this.TAG, 'Found another AVCDecoderConfigurationRecord!');\n        }\n      }\n\n      var version = v.getUint8(0); // configurationVersion\n\n      var avcProfile = v.getUint8(1); // avcProfileIndication\n\n      var profileCompatibility = v.getUint8(2); // profile_compatibility\n\n      var avcLevel = v.getUint8(3); // AVCLevelIndication\n\n      if (version !== 1 || avcProfile === 0) {\n        this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: Invalid AVCDecoderConfigurationRecord');\n\n        return;\n      }\n\n      this._naluLengthSize = (v.getUint8(4) & 3) + 1; // lengthSizeMinusOne\n\n      if (this._naluLengthSize !== 3 && this._naluLengthSize !== 4) {\n        // holy shit!!!\n        this._onError(DemuxErrors.FORMAT_ERROR, \"Flv: Strange NaluLengthSizeMinusOne: \".concat(this._naluLengthSize - 1));\n\n        return;\n      }\n\n      var spsCount = v.getUint8(5) & 31; // numOfSequenceParameterSets\n\n      if (spsCount === 0) {\n        this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: Invalid AVCDecoderConfigurationRecord: No SPS');\n\n        return;\n      } else if (spsCount > 1) {\n        Log.w(this.TAG, \"Flv: Strange AVCDecoderConfigurationRecord: SPS Count = \".concat(spsCount));\n      }\n\n      var offset = 6;\n\n      for (var i = 0; i < spsCount; i++) {\n        var len = v.getUint16(offset, !le); // sequenceParameterSetLength\n\n        offset += 2;\n\n        if (len === 0) {\n          continue;\n        } // Notice: Nalu without startcode header (00 00 00 01)\n\n\n        var sps = new Uint8Array(arrayBuffer, dataOffset + offset, len);\n        offset += len;\n        var config = SPSParser.parseSPS(sps);\n\n        if (i !== 0) {\n          // ignore other sps's config\n          continue;\n        }\n\n        meta.codecWidth = config.codec_size.width;\n        meta.codecHeight = config.codec_size.height;\n        meta.presentWidth = config.present_size.width;\n        meta.presentHeight = config.present_size.height;\n        meta.profile = config.profile_string;\n        meta.level = config.level_string;\n        meta.bitDepth = config.bit_depth;\n        meta.chromaFormat = config.chroma_format;\n        meta.sarRatio = config.sar_ratio;\n        meta.frameRate = config.frame_rate;\n\n        if (config.frame_rate.fixed === false || config.frame_rate.fps_num === 0 || config.frame_rate.fps_den === 0) {\n          meta.frameRate = this._referenceFrameRate;\n        }\n\n        var fps_den = meta.frameRate.fps_den;\n        var fps_num = meta.frameRate.fps_num;\n        meta.refSampleDuration = meta.timescale * (fps_den / fps_num);\n        var codecArray = sps.subarray(1, 4);\n        var codecString = 'avc1.';\n\n        for (var j = 0; j < 3; j++) {\n          var h = codecArray[j].toString(16);\n\n          if (h.length < 2) {\n            h = '0' + h;\n          }\n\n          codecString += h;\n        }\n\n        meta.codec = codecString;\n        var mi = this._mediaInfo;\n        mi.width = meta.codecWidth;\n        mi.height = meta.codecHeight;\n        mi.fps = meta.frameRate.fps;\n        mi.profile = meta.profile;\n        mi.level = meta.level;\n        mi.refFrames = config.ref_frames;\n        mi.chromaFormat = config.chroma_format_string;\n        mi.sarNum = meta.sarRatio.width;\n        mi.sarDen = meta.sarRatio.height;\n        mi.videoCodec = codecString;\n\n        if (mi.hasAudio) {\n          if (mi.audioCodec != null) {\n            mi.mimeType = 'video/x-flv; codecs=\"' + mi.videoCodec + ',' + mi.audioCodec + '\"';\n          }\n        } else {\n          mi.mimeType = 'video/x-flv; codecs=\"' + mi.videoCodec + '\"';\n        }\n\n        if (mi.isComplete()) {\n          this._onMediaInfo(mi);\n        }\n      }\n\n      var ppsCount = v.getUint8(offset); // numOfPictureParameterSets\n\n      if (ppsCount === 0) {\n        this._onError(DemuxErrors.FORMAT_ERROR, 'Flv: Invalid AVCDecoderConfigurationRecord: No PPS');\n\n        return;\n      } else if (ppsCount > 1) {\n        Log.w(this.TAG, \"Flv: Strange AVCDecoderConfigurationRecord: PPS Count = \".concat(ppsCount));\n      }\n\n      offset++;\n\n      for (var _i = 0; _i < ppsCount; _i++) {\n        var _len = v.getUint16(offset, !le); // pictureParameterSetLength\n\n\n        offset += 2;\n\n        if (_len === 0) {\n          continue;\n        } // pps is useless for extracting video information\n\n\n        offset += _len;\n      }\n\n      meta.avcc = new Uint8Array(dataSize);\n      meta.avcc.set(new Uint8Array(arrayBuffer, dataOffset, dataSize), 0);\n      Log.v(this.TAG, 'Parsed AVCDecoderConfigurationRecord');\n\n      if (this._isInitialMetadataDispatched()) {\n        // flush parsed frames\n        if (this._dispatch && (this._audioTrack.length || this._videoTrack.length)) {\n          this._onDataAvailable(this._audioTrack, this._videoTrack);\n        }\n      } else {\n        this._videoInitialMetadataDispatched = true;\n      } // notify new metadata\n\n\n      this._dispatch = false;\n\n      this._onTrackMetadata('video', meta);\n    }\n  }, {\n    key: \"_parseAVCVideoData\",\n    value: function _parseAVCVideoData(arrayBuffer, dataOffset, dataSize, tagTimestamp, tagPosition, frameType, cts) {\n      var le = this._littleEndian;\n      var v = new DataView(arrayBuffer, dataOffset, dataSize);\n      var units = [],\n          length = 0;\n      var offset = 0;\n      var lengthSize = this._naluLengthSize;\n      var dts = this._timestampBase + tagTimestamp;\n      var keyframe = frameType === 1; // from FLV Frame Type constants\n\n      while (offset < dataSize) {\n        if (offset + 4 >= dataSize) {\n          Log.w(this.TAG, \"Malformed Nalu near timestamp \".concat(dts, \", offset = \").concat(offset, \", dataSize = \").concat(dataSize));\n          break; // data not enough for next Nalu\n        } // Nalu with length-header (AVC1)\n\n\n        var naluSize = v.getUint32(offset, !le); // Big-Endian read\n\n        if (lengthSize === 3) {\n          naluSize >>>= 8;\n        }\n\n        if (naluSize > dataSize - lengthSize) {\n          Log.w(this.TAG, \"Malformed Nalus near timestamp \".concat(dts, \", NaluSize > DataSize!\"));\n          return;\n        }\n\n        var unitType = v.getUint8(offset + lengthSize) & 0x1F;\n\n        if (unitType === 5) {\n          // IDR\n          keyframe = true;\n        }\n\n        var data = new Uint8Array(arrayBuffer, dataOffset + offset, lengthSize + naluSize);\n        var unit = {\n          type: unitType,\n          data: data\n        };\n        units.push(unit);\n        length += data.byteLength;\n        offset += lengthSize + naluSize;\n      }\n\n      if (units.length) {\n        var track = this._videoTrack;\n        var avcSample = {\n          units: units,\n          length: length,\n          isKeyframe: keyframe,\n          dts: dts,\n          cts: cts,\n          pts: dts + cts\n        };\n\n        if (keyframe) {\n          avcSample.fileposition = tagPosition;\n        }\n\n        track.samples.push(avcSample);\n        track.length += length;\n      }\n    }\n  }, {\n    key: \"onTrackMetadata\",\n    get: function get() {\n      return this._onTrackMetadata;\n    },\n    set: function set(callback) {\n      this._onTrackMetadata = callback;\n    } // prototype: function(mediaInfo: MediaInfo): void\n\n  }, {\n    key: \"onMediaInfo\",\n    get: function get() {\n      return this._onMediaInfo;\n    },\n    set: function set(callback) {\n      this._onMediaInfo = callback;\n    }\n  }, {\n    key: \"onMetaDataArrived\",\n    get: function get() {\n      return this._onMetaDataArrived;\n    },\n    set: function set(callback) {\n      this._onMetaDataArrived = callback;\n    }\n  }, {\n    key: \"onScriptDataArrived\",\n    get: function get() {\n      return this._onScriptDataArrived;\n    },\n    set: function set(callback) {\n      this._onScriptDataArrived = callback;\n    } // prototype: function(type: number, info: string): void\n\n  }, {\n    key: \"onError\",\n    get: function get() {\n      return this._onError;\n    },\n    set: function set(callback) {\n      this._onError = callback;\n    } // prototype: function(videoTrack: any, audioTrack: any): void\n\n  }, {\n    key: \"onDataAvailable\",\n    get: function get() {\n      return this._onDataAvailable;\n    },\n    set: function set(callback) {\n      this._onDataAvailable = callback;\n    } // timestamp base for output samples, must be in milliseconds\n\n  }, {\n    key: \"timestampBase\",\n    get: function get() {\n      return this._timestampBase;\n    },\n    set: function set(base) {\n      this._timestampBase = base;\n    }\n  }, {\n    key: \"overridedDuration\",\n    get: function get() {\n      return this._duration;\n    } // Force-override media duration. Must be in milliseconds, int32\n    ,\n    set: function set(duration) {\n      this._durationOverrided = true;\n      this._duration = duration;\n      this._mediaInfo.duration = duration;\n    } // Force-override audio track present flag, boolean\n\n  }, {\n    key: \"overridedHasAudio\",\n    set: function set(hasAudio) {\n      this._hasAudioFlagOverrided = true;\n      this._hasAudio = hasAudio;\n      this._mediaInfo.hasAudio = hasAudio;\n    } // Force-override video track present flag, boolean\n\n  }, {\n    key: \"overridedHasVideo\",\n    set: function set(hasVideo) {\n      this._hasVideoFlagOverrided = true;\n      this._hasVideo = hasVideo;\n      this._mediaInfo.hasVideo = hasVideo;\n    }\n  }], [{\n    key: \"probe\",\n    value: function probe(buffer) {\n      var data = new Uint8Array(buffer);\n      var mismatch = {\n        match: false\n      };\n\n      if (data[0] !== 0x46 || data[1] !== 0x4C || data[2] !== 0x56 || data[3] !== 0x01) {\n        return mismatch;\n      }\n\n      var hasAudio = (data[4] & 4) >>> 2 !== 0;\n      var hasVideo = (data[4] & 1) !== 0;\n      var offset = ReadBig32(data, 5);\n\n      if (offset < 9) {\n        return mismatch;\n      }\n\n      return {\n        match: true,\n        consumed: offset,\n        dataOffset: offset,\n        hasAudioTrack: hasAudio,\n        hasVideoTrack: hasVideo\n      };\n    }\n  }]);\n\n  return FLVDemuxer;\n}();\n\nexport default FLVDemuxer;","map":null,"metadata":{},"sourceType":"module"}