{"ast":null,"code":"import _classCallCheck from \"/Users/thurman/CS/React/streams/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _possibleConstructorReturn from \"/Users/thurman/CS/React/streams/client/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/thurman/CS/React/streams/client/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"/Users/thurman/CS/React/streams/client/node_modules/@babel/runtime/helpers/esm/get\";\nimport _createClass from \"/Users/thurman/CS/React/streams/client/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/thurman/CS/React/streams/client/node_modules/@babel/runtime/helpers/esm/inherits\";\n\n/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport Log from '../utils/logger.js';\nimport Browser from '../utils/browser.js';\nimport { BaseLoader, LoaderStatus, LoaderErrors } from './loader.js';\nimport { RuntimeException } from '../utils/exception.js';\n/* fetch + stream IO loader. Currently working on chrome 43+.\n * fetch provides a better alternative http API to XMLHttpRequest\n *\n * fetch spec   https://fetch.spec.whatwg.org/\n * stream spec  https://streams.spec.whatwg.org/\n */\n\nvar FetchStreamLoader =\n/*#__PURE__*/\nfunction (_BaseLoader) {\n  _inherits(FetchStreamLoader, _BaseLoader);\n\n  _createClass(FetchStreamLoader, null, [{\n    key: \"isSupported\",\n    value: function isSupported() {\n      try {\n        // fetch + stream is broken on Microsoft Edge. Disable before build 15048.\n        // see https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8196907/\n        // Fixed in Jan 10, 2017. Build 15048+ removed from blacklist.\n        var isWorkWellEdge = Browser.msedge && Browser.version.minor >= 15048;\n        var browserNotBlacklisted = Browser.msedge ? isWorkWellEdge : true;\n        return self.fetch && self.ReadableStream && browserNotBlacklisted;\n      } catch (e) {\n        return false;\n      }\n    }\n  }]);\n\n  function FetchStreamLoader(seekHandler, config) {\n    var _this;\n\n    _classCallCheck(this, FetchStreamLoader);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(FetchStreamLoader).call(this, 'fetch-stream-loader'));\n    _this.TAG = 'FetchStreamLoader';\n    _this._seekHandler = seekHandler;\n    _this._config = config;\n    _this._needStash = true;\n    _this._requestAbort = false;\n    _this._contentLength = null;\n    _this._receivedLength = 0;\n    return _this;\n  }\n\n  _createClass(FetchStreamLoader, [{\n    key: \"destroy\",\n    value: function destroy() {\n      if (this.isWorking()) {\n        this.abort();\n      }\n\n      _get(_getPrototypeOf(FetchStreamLoader.prototype), \"destroy\", this).call(this);\n    }\n  }, {\n    key: \"open\",\n    value: function open(dataSource, range) {\n      var _this2 = this;\n\n      this._dataSource = dataSource;\n      this._range = range;\n      var sourceURL = dataSource.url;\n\n      if (this._config.reuseRedirectedURL && dataSource.redirectedURL != undefined) {\n        sourceURL = dataSource.redirectedURL;\n      }\n\n      var seekConfig = this._seekHandler.getConfig(sourceURL, range);\n\n      var headers = new self.Headers();\n\n      if (typeof seekConfig.headers === 'object') {\n        var configHeaders = seekConfig.headers;\n\n        for (var key in configHeaders) {\n          if (configHeaders.hasOwnProperty(key)) {\n            headers.append(key, configHeaders[key]);\n          }\n        }\n      }\n\n      var params = {\n        method: 'GET',\n        headers: headers,\n        mode: 'cors',\n        cache: 'default',\n        // The default policy of Fetch API in the whatwg standard\n        // Safari incorrectly indicates 'no-referrer' as default policy, fuck it\n        referrerPolicy: 'no-referrer-when-downgrade'\n      }; // add additional headers\n\n      if (typeof this._config.headers === 'object') {\n        for (var _key in this._config.headers) {\n          headers.append(_key, this._config.headers[_key]);\n        }\n      } // cors is enabled by default\n\n\n      if (dataSource.cors === false) {\n        // no-cors means 'disregard cors policy', which can only be used in ServiceWorker\n        params.mode = 'same-origin';\n      } // withCredentials is disabled by default\n\n\n      if (dataSource.withCredentials) {\n        params.credentials = 'include';\n      } // referrerPolicy from config\n\n\n      if (dataSource.referrerPolicy) {\n        params.referrerPolicy = dataSource.referrerPolicy;\n      }\n\n      this._status = LoaderStatus.kConnecting;\n      self.fetch(seekConfig.url, params).then(function (res) {\n        if (_this2._requestAbort) {\n          _this2._requestAbort = false;\n          _this2._status = LoaderStatus.kIdle;\n          return;\n        }\n\n        if (res.ok && res.status >= 200 && res.status <= 299) {\n          if (res.url !== seekConfig.url) {\n            if (_this2._onURLRedirect) {\n              var redirectedURL = _this2._seekHandler.removeURLParameters(res.url);\n\n              _this2._onURLRedirect(redirectedURL);\n            }\n          }\n\n          var lengthHeader = res.headers.get('Content-Length');\n\n          if (lengthHeader != null) {\n            _this2._contentLength = parseInt(lengthHeader);\n\n            if (_this2._contentLength !== 0) {\n              if (_this2._onContentLengthKnown) {\n                _this2._onContentLengthKnown(_this2._contentLength);\n              }\n            }\n          }\n\n          return _this2._pump.call(_this2, res.body.getReader());\n        } else {\n          _this2._status = LoaderStatus.kError;\n\n          if (_this2._onError) {\n            _this2._onError(LoaderErrors.HTTP_STATUS_CODE_INVALID, {\n              code: res.status,\n              msg: res.statusText\n            });\n          } else {\n            throw new RuntimeException('FetchStreamLoader: Http code invalid, ' + res.status + ' ' + res.statusText);\n          }\n        }\n      }).catch(function (e) {\n        _this2._status = LoaderStatus.kError;\n\n        if (_this2._onError) {\n          _this2._onError(LoaderErrors.EXCEPTION, {\n            code: -1,\n            msg: e.message\n          });\n        } else {\n          throw e;\n        }\n      });\n    }\n  }, {\n    key: \"abort\",\n    value: function abort() {\n      this._requestAbort = true;\n    }\n  }, {\n    key: \"_pump\",\n    value: function _pump(reader) {\n      var _this3 = this;\n\n      // ReadableStreamReader\n      return reader.read().then(function (result) {\n        if (result.done) {\n          // First check received length\n          if (_this3._contentLength !== null && _this3._receivedLength < _this3._contentLength) {\n            // Report Early-EOF\n            _this3._status = LoaderStatus.kError;\n            var type = LoaderErrors.EARLY_EOF;\n            var info = {\n              code: -1,\n              msg: 'Fetch stream meet Early-EOF'\n            };\n\n            if (_this3._onError) {\n              _this3._onError(type, info);\n            } else {\n              throw new RuntimeException(info.msg);\n            }\n          } else {\n            // OK. Download complete\n            _this3._status = LoaderStatus.kComplete;\n\n            if (_this3._onComplete) {\n              _this3._onComplete(_this3._range.from, _this3._range.from + _this3._receivedLength - 1);\n            }\n          }\n        } else {\n          if (_this3._requestAbort === true) {\n            _this3._requestAbort = false;\n            _this3._status = LoaderStatus.kComplete;\n            return reader.cancel();\n          }\n\n          _this3._status = LoaderStatus.kBuffering;\n          var chunk = result.value.buffer;\n          var byteStart = _this3._range.from + _this3._receivedLength;\n          _this3._receivedLength += chunk.byteLength;\n\n          if (_this3._onDataArrival) {\n            _this3._onDataArrival(chunk, byteStart, _this3._receivedLength);\n          }\n\n          _this3._pump(reader);\n        }\n      }).catch(function (e) {\n        if (e.code === 11 && Browser.msedge) {\n          // InvalidStateError on Microsoft Edge\n          // Workaround: Edge may throw InvalidStateError after ReadableStreamReader.cancel() call\n          // Ignore the unknown exception.\n          // Related issue: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11265202/\n          return;\n        }\n\n        _this3._status = LoaderStatus.kError;\n        var type = 0;\n        var info = null;\n\n        if ((e.code === 19 || e.message === 'network error') && ( // NETWORK_ERR\n        _this3._contentLength === null || _this3._contentLength !== null && _this3._receivedLength < _this3._contentLength)) {\n          type = LoaderErrors.EARLY_EOF;\n          info = {\n            code: e.code,\n            msg: 'Fetch stream meet Early-EOF'\n          };\n        } else {\n          type = LoaderErrors.EXCEPTION;\n          info = {\n            code: e.code,\n            msg: e.message\n          };\n        }\n\n        if (_this3._onError) {\n          _this3._onError(type, info);\n        } else {\n          throw new RuntimeException(info.msg);\n        }\n      });\n    }\n  }]);\n\n  return FetchStreamLoader;\n}(BaseLoader);\n\nexport default FetchStreamLoader;","map":null,"metadata":{},"sourceType":"module"}