{"ast":null,"code":"import _classCallCheck from \"/Users/thurman/CS/React/streams/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/thurman/CS/React/streams/client/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/*\n * Copyright (C) 2016 Bilibili. All Rights Reserved.\n *\n * @author zheng qian <xqq@xqq.im>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport EventEmitter from 'events';\nimport Log from '../utils/logger.js';\nimport Browser from '../utils/browser.js';\nimport PlayerEvents from './player-events.js';\nimport Transmuxer from '../core/transmuxer.js';\nimport TransmuxingEvents from '../core/transmuxing-events.js';\nimport MSEController from '../core/mse-controller.js';\nimport MSEEvents from '../core/mse-events.js';\nimport { ErrorTypes, ErrorDetails } from './player-errors.js';\nimport { createDefaultConfig } from '../config.js';\nimport { InvalidArgumentException, IllegalStateException } from '../utils/exception.js';\n\nvar FlvPlayer =\n/*#__PURE__*/\nfunction () {\n  function FlvPlayer(mediaDataSource, config) {\n    _classCallCheck(this, FlvPlayer);\n\n    this.TAG = 'FlvPlayer';\n    this._type = 'FlvPlayer';\n    this._emitter = new EventEmitter();\n    this._config = createDefaultConfig();\n\n    if (typeof config === 'object') {\n      Object.assign(this._config, config);\n    }\n\n    if (mediaDataSource.type.toLowerCase() !== 'flv') {\n      throw new InvalidArgumentException('FlvPlayer requires an flv MediaDataSource input!');\n    }\n\n    if (mediaDataSource.isLive === true) {\n      this._config.isLive = true;\n    }\n\n    this.e = {\n      onvLoadedMetadata: this._onvLoadedMetadata.bind(this),\n      onvSeeking: this._onvSeeking.bind(this),\n      onvCanPlay: this._onvCanPlay.bind(this),\n      onvStalled: this._onvStalled.bind(this),\n      onvProgress: this._onvProgress.bind(this)\n    };\n\n    if (self.performance && self.performance.now) {\n      this._now = self.performance.now.bind(self.performance);\n    } else {\n      this._now = Date.now;\n    }\n\n    this._pendingSeekTime = null; // in seconds\n\n    this._requestSetTime = false;\n    this._seekpointRecord = null;\n    this._progressChecker = null;\n    this._mediaDataSource = mediaDataSource;\n    this._mediaElement = null;\n    this._msectl = null;\n    this._transmuxer = null;\n    this._mseSourceOpened = false;\n    this._hasPendingLoad = false;\n    this._receivedCanPlay = false;\n    this._mediaInfo = null;\n    this._statisticsInfo = null;\n    var chromeNeedIDRFix = Browser.chrome && (Browser.version.major < 50 || Browser.version.major === 50 && Browser.version.build < 2661);\n    this._alwaysSeekKeyframe = chromeNeedIDRFix || Browser.msedge || Browser.msie ? true : false;\n\n    if (this._alwaysSeekKeyframe) {\n      this._config.accurateSeek = false;\n    }\n  }\n\n  _createClass(FlvPlayer, [{\n    key: \"destroy\",\n    value: function destroy() {\n      if (this._progressChecker != null) {\n        window.clearInterval(this._progressChecker);\n        this._progressChecker = null;\n      }\n\n      if (this._transmuxer) {\n        this.unload();\n      }\n\n      if (this._mediaElement) {\n        this.detachMediaElement();\n      }\n\n      this.e = null;\n      this._mediaDataSource = null;\n\n      this._emitter.removeAllListeners();\n\n      this._emitter = null;\n    }\n  }, {\n    key: \"on\",\n    value: function on(event, listener) {\n      var _this = this;\n\n      if (event === PlayerEvents.MEDIA_INFO) {\n        if (this._mediaInfo != null) {\n          Promise.resolve().then(function () {\n            _this._emitter.emit(PlayerEvents.MEDIA_INFO, _this.mediaInfo);\n          });\n        }\n      } else if (event === PlayerEvents.STATISTICS_INFO) {\n        if (this._statisticsInfo != null) {\n          Promise.resolve().then(function () {\n            _this._emitter.emit(PlayerEvents.STATISTICS_INFO, _this.statisticsInfo);\n          });\n        }\n      }\n\n      this._emitter.addListener(event, listener);\n    }\n  }, {\n    key: \"off\",\n    value: function off(event, listener) {\n      this._emitter.removeListener(event, listener);\n    }\n  }, {\n    key: \"attachMediaElement\",\n    value: function attachMediaElement(mediaElement) {\n      var _this2 = this;\n\n      this._mediaElement = mediaElement;\n      mediaElement.addEventListener('loadedmetadata', this.e.onvLoadedMetadata);\n      mediaElement.addEventListener('seeking', this.e.onvSeeking);\n      mediaElement.addEventListener('canplay', this.e.onvCanPlay);\n      mediaElement.addEventListener('stalled', this.e.onvStalled);\n      mediaElement.addEventListener('progress', this.e.onvProgress);\n      this._msectl = new MSEController(this._config);\n\n      this._msectl.on(MSEEvents.UPDATE_END, this._onmseUpdateEnd.bind(this));\n\n      this._msectl.on(MSEEvents.BUFFER_FULL, this._onmseBufferFull.bind(this));\n\n      this._msectl.on(MSEEvents.SOURCE_OPEN, function () {\n        _this2._mseSourceOpened = true;\n\n        if (_this2._hasPendingLoad) {\n          _this2._hasPendingLoad = false;\n\n          _this2.load();\n        }\n      });\n\n      this._msectl.on(MSEEvents.ERROR, function (info) {\n        _this2._emitter.emit(PlayerEvents.ERROR, ErrorTypes.MEDIA_ERROR, ErrorDetails.MEDIA_MSE_ERROR, info);\n      });\n\n      this._msectl.attachMediaElement(mediaElement);\n\n      if (this._pendingSeekTime != null) {\n        try {\n          mediaElement.currentTime = this._pendingSeekTime;\n          this._pendingSeekTime = null;\n        } catch (e) {// IE11 may throw InvalidStateError if readyState === 0\n          // We can defer set currentTime operation after loadedmetadata\n        }\n      }\n    }\n  }, {\n    key: \"detachMediaElement\",\n    value: function detachMediaElement() {\n      if (this._mediaElement) {\n        this._msectl.detachMediaElement();\n\n        this._mediaElement.removeEventListener('loadedmetadata', this.e.onvLoadedMetadata);\n\n        this._mediaElement.removeEventListener('seeking', this.e.onvSeeking);\n\n        this._mediaElement.removeEventListener('canplay', this.e.onvCanPlay);\n\n        this._mediaElement.removeEventListener('stalled', this.e.onvStalled);\n\n        this._mediaElement.removeEventListener('progress', this.e.onvProgress);\n\n        this._mediaElement = null;\n      }\n\n      if (this._msectl) {\n        this._msectl.destroy();\n\n        this._msectl = null;\n      }\n    }\n  }, {\n    key: \"load\",\n    value: function load() {\n      var _this3 = this;\n\n      if (!this._mediaElement) {\n        throw new IllegalStateException('HTMLMediaElement must be attached before load()!');\n      }\n\n      if (this._transmuxer) {\n        throw new IllegalStateException('FlvPlayer.load() has been called, please call unload() first!');\n      }\n\n      if (this._hasPendingLoad) {\n        return;\n      }\n\n      if (this._config.deferLoadAfterSourceOpen && this._mseSourceOpened === false) {\n        this._hasPendingLoad = true;\n        return;\n      }\n\n      if (this._mediaElement.readyState > 0) {\n        this._requestSetTime = true; // IE11 may throw InvalidStateError if readyState === 0\n\n        this._mediaElement.currentTime = 0;\n      }\n\n      this._transmuxer = new Transmuxer(this._mediaDataSource, this._config);\n\n      this._transmuxer.on(TransmuxingEvents.INIT_SEGMENT, function (type, is) {\n        _this3._msectl.appendInitSegment(is);\n      });\n\n      this._transmuxer.on(TransmuxingEvents.MEDIA_SEGMENT, function (type, ms) {\n        _this3._msectl.appendMediaSegment(ms); // lazyLoad check\n\n\n        if (_this3._config.lazyLoad && !_this3._config.isLive) {\n          var currentTime = _this3._mediaElement.currentTime;\n\n          if (ms.info.endDts >= (currentTime + _this3._config.lazyLoadMaxDuration) * 1000) {\n            if (_this3._progressChecker == null) {\n              Log.v(_this3.TAG, 'Maximum buffering duration exceeded, suspend transmuxing task');\n\n              _this3._suspendTransmuxer();\n            }\n          }\n        }\n      });\n\n      this._transmuxer.on(TransmuxingEvents.LOADING_COMPLETE, function () {\n        _this3._msectl.endOfStream();\n\n        _this3._emitter.emit(PlayerEvents.LOADING_COMPLETE);\n      });\n\n      this._transmuxer.on(TransmuxingEvents.RECOVERED_EARLY_EOF, function () {\n        _this3._emitter.emit(PlayerEvents.RECOVERED_EARLY_EOF);\n      });\n\n      this._transmuxer.on(TransmuxingEvents.IO_ERROR, function (detail, info) {\n        _this3._emitter.emit(PlayerEvents.ERROR, ErrorTypes.NETWORK_ERROR, detail, info);\n      });\n\n      this._transmuxer.on(TransmuxingEvents.DEMUX_ERROR, function (detail, info) {\n        _this3._emitter.emit(PlayerEvents.ERROR, ErrorTypes.MEDIA_ERROR, detail, {\n          code: -1,\n          msg: info\n        });\n      });\n\n      this._transmuxer.on(TransmuxingEvents.MEDIA_INFO, function (mediaInfo) {\n        _this3._mediaInfo = mediaInfo;\n\n        _this3._emitter.emit(PlayerEvents.MEDIA_INFO, Object.assign({}, mediaInfo));\n      });\n\n      this._transmuxer.on(TransmuxingEvents.METADATA_ARRIVED, function (metadata) {\n        _this3._emitter.emit(PlayerEvents.METADATA_ARRIVED, metadata);\n      });\n\n      this._transmuxer.on(TransmuxingEvents.SCRIPTDATA_ARRIVED, function (data) {\n        _this3._emitter.emit(PlayerEvents.SCRIPTDATA_ARRIVED, data);\n      });\n\n      this._transmuxer.on(TransmuxingEvents.STATISTICS_INFO, function (statInfo) {\n        _this3._statisticsInfo = _this3._fillStatisticsInfo(statInfo);\n\n        _this3._emitter.emit(PlayerEvents.STATISTICS_INFO, Object.assign({}, _this3._statisticsInfo));\n      });\n\n      this._transmuxer.on(TransmuxingEvents.RECOMMEND_SEEKPOINT, function (milliseconds) {\n        if (_this3._mediaElement && !_this3._config.accurateSeek) {\n          _this3._requestSetTime = true;\n          _this3._mediaElement.currentTime = milliseconds / 1000;\n        }\n      });\n\n      this._transmuxer.open();\n    }\n  }, {\n    key: \"unload\",\n    value: function unload() {\n      if (this._mediaElement) {\n        this._mediaElement.pause();\n      }\n\n      if (this._msectl) {\n        this._msectl.seek(0);\n      }\n\n      if (this._transmuxer) {\n        this._transmuxer.close();\n\n        this._transmuxer.destroy();\n\n        this._transmuxer = null;\n      }\n    }\n  }, {\n    key: \"play\",\n    value: function play() {\n      return this._mediaElement.play();\n    }\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      this._mediaElement.pause();\n    }\n  }, {\n    key: \"_fillStatisticsInfo\",\n    value: function _fillStatisticsInfo(statInfo) {\n      statInfo.playerType = this._type;\n\n      if (!(this._mediaElement instanceof HTMLVideoElement)) {\n        return statInfo;\n      }\n\n      var hasQualityInfo = true;\n      var decoded = 0;\n      var dropped = 0;\n\n      if (this._mediaElement.getVideoPlaybackQuality) {\n        var quality = this._mediaElement.getVideoPlaybackQuality();\n\n        decoded = quality.totalVideoFrames;\n        dropped = quality.droppedVideoFrames;\n      } else if (this._mediaElement.webkitDecodedFrameCount != undefined) {\n        decoded = this._mediaElement.webkitDecodedFrameCount;\n        dropped = this._mediaElement.webkitDroppedFrameCount;\n      } else {\n        hasQualityInfo = false;\n      }\n\n      if (hasQualityInfo) {\n        statInfo.decodedFrames = decoded;\n        statInfo.droppedFrames = dropped;\n      }\n\n      return statInfo;\n    }\n  }, {\n    key: \"_onmseUpdateEnd\",\n    value: function _onmseUpdateEnd() {\n      if (!this._config.lazyLoad || this._config.isLive) {\n        return;\n      }\n\n      var buffered = this._mediaElement.buffered;\n      var currentTime = this._mediaElement.currentTime;\n      var currentRangeStart = 0;\n      var currentRangeEnd = 0;\n\n      for (var i = 0; i < buffered.length; i++) {\n        var start = buffered.start(i);\n        var end = buffered.end(i);\n\n        if (start <= currentTime && currentTime < end) {\n          currentRangeStart = start;\n          currentRangeEnd = end;\n          break;\n        }\n      }\n\n      if (currentRangeEnd >= currentTime + this._config.lazyLoadMaxDuration && this._progressChecker == null) {\n        Log.v(this.TAG, 'Maximum buffering duration exceeded, suspend transmuxing task');\n\n        this._suspendTransmuxer();\n      }\n    }\n  }, {\n    key: \"_onmseBufferFull\",\n    value: function _onmseBufferFull() {\n      Log.v(this.TAG, 'MSE SourceBuffer is full, suspend transmuxing task');\n\n      if (this._progressChecker == null) {\n        this._suspendTransmuxer();\n      }\n    }\n  }, {\n    key: \"_suspendTransmuxer\",\n    value: function _suspendTransmuxer() {\n      if (this._transmuxer) {\n        this._transmuxer.pause();\n\n        if (this._progressChecker == null) {\n          this._progressChecker = window.setInterval(this._checkProgressAndResume.bind(this), 1000);\n        }\n      }\n    }\n  }, {\n    key: \"_checkProgressAndResume\",\n    value: function _checkProgressAndResume() {\n      var currentTime = this._mediaElement.currentTime;\n      var buffered = this._mediaElement.buffered;\n      var needResume = false;\n\n      for (var i = 0; i < buffered.length; i++) {\n        var from = buffered.start(i);\n        var to = buffered.end(i);\n\n        if (currentTime >= from && currentTime < to) {\n          if (currentTime >= to - this._config.lazyLoadRecoverDuration) {\n            needResume = true;\n          }\n\n          break;\n        }\n      }\n\n      if (needResume) {\n        window.clearInterval(this._progressChecker);\n        this._progressChecker = null;\n\n        if (needResume) {\n          Log.v(this.TAG, 'Continue loading from paused position');\n\n          this._transmuxer.resume();\n        }\n      }\n    }\n  }, {\n    key: \"_isTimepointBuffered\",\n    value: function _isTimepointBuffered(seconds) {\n      var buffered = this._mediaElement.buffered;\n\n      for (var i = 0; i < buffered.length; i++) {\n        var from = buffered.start(i);\n        var to = buffered.end(i);\n\n        if (seconds >= from && seconds < to) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_internalSeek\",\n    value: function _internalSeek(seconds) {\n      var directSeek = this._isTimepointBuffered(seconds);\n\n      var directSeekBegin = false;\n      var directSeekBeginTime = 0;\n\n      if (seconds < 1.0 && this._mediaElement.buffered.length > 0) {\n        var videoBeginTime = this._mediaElement.buffered.start(0);\n\n        if (videoBeginTime < 1.0 && seconds < videoBeginTime || Browser.safari) {\n          directSeekBegin = true; // also workaround for Safari: Seek to 0 may cause video stuck, use 0.1 to avoid\n\n          directSeekBeginTime = Browser.safari ? 0.1 : videoBeginTime;\n        }\n      }\n\n      if (directSeekBegin) {\n        // seek to video begin, set currentTime directly if beginPTS buffered\n        this._requestSetTime = true;\n        this._mediaElement.currentTime = directSeekBeginTime;\n      } else if (directSeek) {\n        // buffered position\n        if (!this._alwaysSeekKeyframe) {\n          this._requestSetTime = true;\n          this._mediaElement.currentTime = seconds;\n        } else {\n          var idr = this._msectl.getNearestKeyframe(Math.floor(seconds * 1000));\n\n          this._requestSetTime = true;\n\n          if (idr != null) {\n            this._mediaElement.currentTime = idr.dts / 1000;\n          } else {\n            this._mediaElement.currentTime = seconds;\n          }\n        }\n\n        if (this._progressChecker != null) {\n          this._checkProgressAndResume();\n        }\n      } else {\n        if (this._progressChecker != null) {\n          window.clearInterval(this._progressChecker);\n          this._progressChecker = null;\n        }\n\n        this._msectl.seek(seconds);\n\n        this._transmuxer.seek(Math.floor(seconds * 1000)); // in milliseconds\n        // no need to set mediaElement.currentTime if non-accurateSeek,\n        // just wait for the recommend_seekpoint callback\n\n\n        if (this._config.accurateSeek) {\n          this._requestSetTime = true;\n          this._mediaElement.currentTime = seconds;\n        }\n      }\n    }\n  }, {\n    key: \"_checkAndApplyUnbufferedSeekpoint\",\n    value: function _checkAndApplyUnbufferedSeekpoint() {\n      if (this._seekpointRecord) {\n        if (this._seekpointRecord.recordTime <= this._now() - 100) {\n          var target = this._mediaElement.currentTime;\n          this._seekpointRecord = null;\n\n          if (!this._isTimepointBuffered(target)) {\n            if (this._progressChecker != null) {\n              window.clearTimeout(this._progressChecker);\n              this._progressChecker = null;\n            } // .currentTime is consists with .buffered timestamp\n            // Chrome/Edge use DTS, while FireFox/Safari use PTS\n\n\n            this._msectl.seek(target);\n\n            this._transmuxer.seek(Math.floor(target * 1000)); // set currentTime if accurateSeek, or wait for recommend_seekpoint callback\n\n\n            if (this._config.accurateSeek) {\n              this._requestSetTime = true;\n              this._mediaElement.currentTime = target;\n            }\n          }\n        } else {\n          window.setTimeout(this._checkAndApplyUnbufferedSeekpoint.bind(this), 50);\n        }\n      }\n    }\n  }, {\n    key: \"_checkAndResumeStuckPlayback\",\n    value: function _checkAndResumeStuckPlayback(stalled) {\n      var media = this._mediaElement;\n\n      if (stalled || !this._receivedCanPlay || media.readyState < 2) {\n        // HAVE_CURRENT_DATA\n        var buffered = media.buffered;\n\n        if (buffered.length > 0 && media.currentTime < buffered.start(0)) {\n          Log.w(this.TAG, \"Playback seems stuck at \".concat(media.currentTime, \", seek to \").concat(buffered.start(0)));\n          this._requestSetTime = true;\n          this._mediaElement.currentTime = buffered.start(0);\n\n          this._mediaElement.removeEventListener('progress', this.e.onvProgress);\n        }\n      } else {\n        // Playback didn't stuck, remove progress event listener\n        this._mediaElement.removeEventListener('progress', this.e.onvProgress);\n      }\n    }\n  }, {\n    key: \"_onvLoadedMetadata\",\n    value: function _onvLoadedMetadata(e) {\n      if (this._pendingSeekTime != null) {\n        this._mediaElement.currentTime = this._pendingSeekTime;\n        this._pendingSeekTime = null;\n      }\n    }\n  }, {\n    key: \"_onvSeeking\",\n    value: function _onvSeeking(e) {\n      // handle seeking request from browser's progress bar\n      var target = this._mediaElement.currentTime;\n      var buffered = this._mediaElement.buffered;\n\n      if (this._requestSetTime) {\n        this._requestSetTime = false;\n        return;\n      }\n\n      if (target < 1.0 && buffered.length > 0) {\n        // seek to video begin, set currentTime directly if beginPTS buffered\n        var videoBeginTime = buffered.start(0);\n\n        if (videoBeginTime < 1.0 && target < videoBeginTime || Browser.safari) {\n          this._requestSetTime = true; // also workaround for Safari: Seek to 0 may cause video stuck, use 0.1 to avoid\n\n          this._mediaElement.currentTime = Browser.safari ? 0.1 : videoBeginTime;\n          return;\n        }\n      }\n\n      if (this._isTimepointBuffered(target)) {\n        if (this._alwaysSeekKeyframe) {\n          var idr = this._msectl.getNearestKeyframe(Math.floor(target * 1000));\n\n          if (idr != null) {\n            this._requestSetTime = true;\n            this._mediaElement.currentTime = idr.dts / 1000;\n          }\n        }\n\n        if (this._progressChecker != null) {\n          this._checkProgressAndResume();\n        }\n\n        return;\n      }\n\n      this._seekpointRecord = {\n        seekPoint: target,\n        recordTime: this._now()\n      };\n      window.setTimeout(this._checkAndApplyUnbufferedSeekpoint.bind(this), 50);\n    }\n  }, {\n    key: \"_onvCanPlay\",\n    value: function _onvCanPlay(e) {\n      this._receivedCanPlay = true;\n\n      this._mediaElement.removeEventListener('canplay', this.e.onvCanPlay);\n    }\n  }, {\n    key: \"_onvStalled\",\n    value: function _onvStalled(e) {\n      this._checkAndResumeStuckPlayback(true);\n    }\n  }, {\n    key: \"_onvProgress\",\n    value: function _onvProgress(e) {\n      this._checkAndResumeStuckPlayback();\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this._type;\n    }\n  }, {\n    key: \"buffered\",\n    get: function get() {\n      return this._mediaElement.buffered;\n    }\n  }, {\n    key: \"duration\",\n    get: function get() {\n      return this._mediaElement.duration;\n    }\n  }, {\n    key: \"volume\",\n    get: function get() {\n      return this._mediaElement.volume;\n    },\n    set: function set(value) {\n      this._mediaElement.volume = value;\n    }\n  }, {\n    key: \"muted\",\n    get: function get() {\n      return this._mediaElement.muted;\n    },\n    set: function set(muted) {\n      this._mediaElement.muted = muted;\n    }\n  }, {\n    key: \"currentTime\",\n    get: function get() {\n      if (this._mediaElement) {\n        return this._mediaElement.currentTime;\n      }\n\n      return 0;\n    },\n    set: function set(seconds) {\n      if (this._mediaElement) {\n        this._internalSeek(seconds);\n      } else {\n        this._pendingSeekTime = seconds;\n      }\n    }\n  }, {\n    key: \"mediaInfo\",\n    get: function get() {\n      return Object.assign({}, this._mediaInfo);\n    }\n  }, {\n    key: \"statisticsInfo\",\n    get: function get() {\n      if (this._statisticsInfo == null) {\n        this._statisticsInfo = {};\n      }\n\n      this._statisticsInfo = this._fillStatisticsInfo(this._statisticsInfo);\n      return Object.assign({}, this._statisticsInfo);\n    }\n  }]);\n\n  return FlvPlayer;\n}();\n\nexport default FlvPlayer;","map":null,"metadata":{},"sourceType":"module"}